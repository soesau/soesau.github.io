<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Surface_mesh_shortest_path/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - Triangulated Surface Mesh Shortest Paths: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Triangulated Surface Mesh Shortest Paths
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Surface_mesh_shortest_path"></a><a class="anchor" id="chaptersurfacemeshshortestpath"></a></p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Stephen Kiazyk, Sébastien Loriot, and Éric Colin de Verdière</dd></dl>
<p>This package provides an algorithm to compute geodesic shortest paths on a triangulated surface mesh.</p>
<p><a class="anchor" id="fig__Shortest_path_main"></a> </p><div class="image">
<img src="shortest_paths_overview.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Shortest_path_main">Figure 77.1</a> Shortest paths on a terrain using one source point represented by a green square. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="Surface_mesh_shortest_pathIntroduction"></a>
Introduction</h1>
<p>The motion planning of a robot across the surface of a 3-dimensional terrain is a typical application of the shortest path computation. Using a 2-dimensional approximation would fail to capture anything interesting about the terrain we are trying to cross, and would give a poor solution. The problem is often called the <em>Discrete Geodesic Problem</em>. Although the more general version of this problem, shortest paths in 3D in the presence of obstacles, is NP-Hard, when the motion is constrained to the 2D surface of an object it can be solved efficiently.</p>
<p>The algorithm implemented in this package builds a data structure to efficiently answer queries of the following form: Given a triangulated surface mesh \(\cal{M}\), a set of source points \(S\) on \(\cal{M}\), and a target point \(t\) also on \(\cal{M}\), find a shortest path \(\lambda\) between \(t\) and any element in \( S \), where \(\lambda\) is constrained to the surface of \(\cal{M}\).</p>
<p>The algorithm used is based on a paper by Xin and Wang <a class="el" href="citelist.html#CITEREF_XinWang2009improvingchenandhan">[3]</a>, a fast and practical algorithm for exact computation of geodesic shortest paths. It is an extension of earlier results by Chen and Han <a class="el" href="citelist.html#CITEREF_ch-spp-96">[1]</a> and Mitchell, Mount, and Papadimitriou <a class="el" href="citelist.html#CITEREF_mmp-dgp-87">[2]</a> .</p>
<p>This package is related to the package <a class="elRef" href="../Manual/packages.html#PkgHeatMethod">The Heat Method</a>. Both deal with geodesic distances. The geodesic shortest path package computes the exact shortest path between any two points on the surface. The heat method package computes for every vertex of a mesh an approximate distance to one or several source vertices.</p>
<h1><a class="anchor" id="Surface_mesh_shortest_pathHowToUse"></a>
User Interface Description</h1>
<h2><a class="anchor" id="Surface_mesh_shortest_pathClass"></a>
Surface Mesh Shortest Path Class</h2>
<p>The main class of this package is <code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html" title="Computes shortest surface paths from one or more source points on a surface mesh.">Surface_mesh_shortest_path</a></code>. In the following we describe the typical workflow when using this class</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathClassInput"></a>
Specifying the Input</h3>
<p>The shortest paths are computed on a triangulated surface mesh, represented by a model of the <code><a class="elRef" href="../BGL/class_face_list_graph.html">FaceListGraph</a></code> concept. There is no restriction on the genus, connectivity, or convexity of the input surface mesh.</p>
<p>For efficiency reason, index property maps for vertices, halfedges and faces are internally used. For each simplex type the property map must provide an index between 0 and the number of simplices. We recommend to use the class <code><a class="elRef" href="../Surface_mesh/class_c_g_a_l_1_1_surface__mesh.html">CGAL::Surface_mesh</a></code> as model of <code><a class="elRef" href="../BGL/class_face_list_graph.html">FaceListGraph</a></code>. If you use the class <code><a class="elRef" href="../Polyhedron/class_c_g_a_l_1_1_polyhedron__3.html">CGAL::Polyhedron_3</a></code>, you should use it with the item class <code><a class="elRef" href="../BGL/class_c_g_a_l_1_1_polyhedron__items__with__id__3.html">CGAL::Polyhedron_items_with_id_3</a></code>, for which default property maps are provided. This item class associates to each simplex an index that provides a \(O(1)\) time access to the indices. Note that the initialization of the property maps requires a call to <code><a class="elRef" href="../BGL/group___b_g_l_graph_external_indices.html#ga0660924a1aa87e8be5cccbc261e931c7">set_halfedgeds_items_id()</a></code>.</p>
<p>The access to the embedding of each vertex is done using a point vertex property map associating to each vertex a 3D point. Defaults are provided for CGAL classes.</p>
<p>If the traits class used holds some local state, it must also be passed to the class when constructing it (the default one provided does not).</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathClassSource"></a>
Specifying the Source Points</h3>
<p>The set of source points for shortest path queries can be populated one by one or using a range. A source point can be specified using either a vertex of the input surface mesh or a face of the input surface mesh with some barycentric coordinates. Given a point \(p\) that lies inside a triangle face \((A,B,C)\), its barycentric coordinates are a weight triple \((b_0,b_1,b_2)\) such that \(p = b_0\cdot~A + b_1\cdot~B + b_2\cdot~C\), and \(b_0 + b_1 + b_2 = 1\).</p>
<p>For convenience, a function <code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#aeef6cd8e8c10b5c8c3ebb0388664ff1a" title="returns the nearest face location to the given point.">Surface_mesh_shortest_path::locate()</a></code> is provided to construct face locations from geometric inputs:</p><ul>
<li>given a point <code>p</code> living in 3D space, this function computes the point closest to <code>p</code> on the surface, and returns the face containing this point, as well as its barycentric coordinates;</li>
<li>given a ray <code>r</code> living in 3D space, this function computes the intersection of the ray with the surface, and (if an intersection exists) returns the face containing this point, as well as its barycentric coordinates;</li>
</ul>
<p>Usage of this function is illustrated in the example <a class="el" href="_surface_mesh_shortest_path_2shortest_path_with_locate_8cpp-example.html">Surface_mesh_shortest_path/shortest_path_with_locate.cpp</a>.</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathClassBuild"></a>
Building the Internal Sequence Tree</h3>
<p>A time consuming operation for shortest path queries consists in building an internal data structure used to make the queries. This data structure is called the <em>sequence tree</em>. It will be built automatically when the first shortest path query is done and will be reused for any subsequent query as long as the set of source points does not change. Each time the set of source points is changed the sequence tree needs to be rebuilt (if already built). Note that it can also be built manually by a call to <code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a09ce4f3420206eca88e44a73677d18b6" title="Computes all pending changes to the internal sequence tree.">Surface_mesh_shortest_path::build_sequence_tree()</a></code>.</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathClassQueries"></a>
Shortest Path Queries</h3>
<p>As for specifying the source points, the target point for a shortest path query can be specified using either a vertex of the input surface mesh or a face of the input surface mesh and some barycentric coordinates.</p>
<p>There are three different kinds of query functions that can be called using the class <code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html" title="Computes shortest surface paths from one or more source points on a surface mesh.">Surface_mesh_shortest_path</a></code>. Given a target point, all these functions compute the shortest path between that target point and the set of source points:</p>
<ul>
<li><code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a4bb93883c11c9e5ecac86449d5bb4eac" title="Computes the shortest surface distance from a vertex to any source point.">Surface_mesh_shortest_path::shortest_distance_to_source_points()</a></code> provides the closest source point to the target point together with the length of the shortest path.</li>
<li><code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a94e35adf196a1d2a9d1f5b8c679c8a8c" title="Computes the sequence of points in the shortest path along the surface of the input face graph from t...">Surface_mesh_shortest_path::shortest_path_points_to_source_points()</a></code> provides all the intersection points of the shortest path with the edges and vertices of the input surface mesh (including the source and the target point). This function is useful for visualization purposes.</li>
<li><code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#abae724fffbf4e53700180e73b9256e9d" title="visits the sequence of edges, vertices and faces traversed by the shortest path from a vertex to any ...">Surface_mesh_shortest_path::shortest_path_sequence_to_source_points</a></code> gives access to the complete sequence of simplices crossed by the shortest path using a visitor object model of the concept <code><a class="el" href="class_surface_mesh_shortest_path_visitor.html" title="The concept SurfaceMeshShortestPathVisitor describes the requirements of the visitor type used to col...">SurfaceMeshShortestPathVisitor</a></code>.</li>
</ul>
<h3><a class="anchor" id="Surface_mesh_shortest_pathClassMore"></a>
Additional Convenience Functionalities</h3>
<p>Some convenience functions are provided to compute:</p><ul>
<li>the point on the input surface mesh specified as a face of the input surface mesh and some barycentric coordinates.</li>
<li>the closest point on the input surface mesh (specified as a face of the input surface mesh and some barycentric coordinates) to a given 3D point. Those function are using the class <code><a class="elRef" href="../AABB_tree/class_c_g_a_l_1_1_a_a_b_b__tree.html">CGAL::AABB_tree</a></code>.</li>
</ul>
<h2><a class="anchor" id="Surface_mesh_shortest_pathKernelRecommendataions"></a>
Kernel Recommendations</h2>
<p>In short, we recommend to use a CGAL kernel with exact predicates such as <code><a class="elRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>.</p>
<p>If you need the constructions to be exact (for the shortest path point computation for example), you should use a kernel with exact constructions. Although the algorithm uses square root operations, it will also work on geometry kernels which do not support them by first converting the kernel's number type to <code>double</code>, using the <code>std::sqrt</code>, and converting it back. Note that it would be preferable to use a kernel with directly supports square roots to get the most precision of the shortest path computations.</p>
<p>Using a kernel such as <code><a class="elRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__exact__constructions__kernel__with__sqrt.html">CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt</a></code> with this package will indeed provide the exact shortest paths, but it will be extremely slow. Indeed, in order to compute the distance along the surface, it is necessary to unfold sequences of faces, edge-to-edge, out into a common plane. The functor <code><a class="el" href="class_surface_mesh_shortest_path_traits.html#ab8504388037d732997ac864ef270ec94" title="Function object type that provides Triangle_2 operator()(Triangle_3 t) which computes a 2-dimensional...">SurfaceMeshShortestPathTraits::Construct_triangle_3_to_triangle_2_projection</a></code> provides an initial layout of the first face in a sequence, by rotating a given face into the <code>xy</code>-plane. <code><a class="el" href="class_surface_mesh_shortest_path_traits.html#a5097cc568d60214389dbee34eac94f07" title="Function object type that provides Triangle_2 operator()(Triangle_3 t, std::size_t i,...">SurfaceMeshShortestPathTraits::Construct_triangle_3_along_segment_2_flattening</a></code> unfolds a triangle into the plane, using a specified segment as a base. Since this results in a chain of constructed triangles in the plane, the exact representation types used with this kernel (either <code><a class="elRef" href="../Number_types/class_c_o_r_e_1_1_expr.html">CORE::Expr</a></code> or <code><a class="elRef" href="../Number_types/classleda__real.html">leda_real</a></code>) will process extremely slow, even on very simple inputs. This is because the exact representations will effectively add an \(O(n)\) factor to every computation.</p>
<h1><a class="anchor" id="Surface_mesh_shortest_pathExamples"></a>
Examples</h1>
<h2><a class="anchor" id="Surface_mesh_shortest_pathSimpleExample"></a>
Simple Example</h2>
<p>The following example shows how to get the shortest path to every vertex from an arbitrary source point on a surface. The shortest path class needs to have an index associated to each vertex, halfedge and face, which is naturally given for the class <code><a class="elRef" href="../Surface_mesh/class_c_g_a_l_1_1_surface__mesh.html">Surface_mesh</a></code>.</p>
<p><br>
<b>File</b> <a class="el" href="_surface_mesh_shortest_path_2shortest_paths_8cpp-example.html">Surface_mesh_shortest_path/shortest_paths.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_surface__mesh__shortest__path_8h.html">CGAL/Surface_mesh_shortest_path.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/class_c_g_a_l_1_1_surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Triangle_mesh;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path__traits.html">CGAL::Surface_mesh_shortest_path_traits&lt;Kernel, Triangle_mesh&gt;</a> Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html">CGAL::Surface_mesh_shortest_path&lt;Traits&gt;</a> Surface_mesh_shortest_path;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt; Graph_traits;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::vertex_iterator vertex_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_iterator face_iterator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/elephant.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Triangle_mesh tmesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group___pkg_b_g_l_i_o_fct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, tmesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group___pkg_b_g_l_helper_fct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(tmesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pick up a random face</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randSeed = argc &gt; 2 ? boost::lexical_cast&lt;unsigned int&gt;(argv[2]) : 7915421;</div>
<div class="line">  CGAL::Random rand(randSeed);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> target_face_index = rand.get_int(0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(num_faces(tmesh)));</div>
<div class="line">  face_iterator face_it = faces(tmesh).first;</div>
<div class="line">  std::advance(face_it,target_face_index);</div>
<div class="line">  <span class="comment">// ... and define a barycentric coordinates inside the face</span></div>
<div class="line">  Traits::Barycentric_coordinates face_location = {{0.25, 0.5, 0.25}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construct a shortest path query object and add a source point</span></div>
<div class="line">  Surface_mesh_shortest_path shortest_paths(tmesh);</div>
<div class="line">  shortest_paths.add_source_point(*face_it, face_location);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// For all vertices in the tmesh, compute the points of</span></div>
<div class="line">  <span class="comment">// the shortest path to the source point and write them</span></div>
<div class="line">  <span class="comment">// into a file readable using CGAL Lab</span></div>
<div class="line">  std::ofstream output(<span class="stringliteral">"shortest_paths_with_id.polylines.txt"</span>);</div>
<div class="line">  vertex_iterator vit, vit_end;</div>
<div class="line">  <span class="keywordflow">for</span> ( boost::tie(vit, vit_end) = vertices(tmesh);</div>
<div class="line">        vit != vit_end; ++vit)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;Traits::Point_3&gt; points;</div>
<div class="line">    shortest_paths.shortest_path_points_to_source_points(*vit, std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print the points</span></div>
<div class="line">    output &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; points.size(); ++i)</div>
<div class="line">      output &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; points[i];</div>
<div class="line">    output &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_surface__mesh__shortest__path_8h_html"><div class="ttname"><a href="_surface__mesh__shortest__path_8h.html">Surface_mesh_shortest_path.h</a></div><div class="ttdoc">Convenience header file only including CGAL/Surface_mesh_shortest_path/Surface_mesh_shortest_path....</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_surface__mesh__shortest__path__traits_html"><div class="ttname"><a href="class_c_g_a_l_1_1_surface__mesh__shortest__path__traits.html">CGAL::Surface_mesh_shortest_path_traits</a></div><div class="ttdoc">A model of the concept SurfaceMeshShortestPathTraits as required by the Surface_mesh_shortest_path cl...</div><div class="ttdef"><b>Definition:</b> Surface_mesh_shortest_path_traits.h:43</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_surface__mesh__shortest__path_html"><div class="ttname"><a href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html">CGAL::Surface_mesh_shortest_path</a></div><div class="ttdoc">Computes shortest surface paths from one or more source points on a surface mesh.</div><div class="ttdef"><b>Definition:</b> Surface_mesh_shortest_path.h:73</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_surface__mesh_html"><div class="ttname"><a href="../Surface_mesh/class_c_g_a_l_1_1_surface__mesh.html">CGAL::Surface_mesh</a></div></div>
<div class="ttc" id="agroup___pkg_b_g_l_helper_fct_html_ga11883d231eec1b58f37efe4acedd9588"><div class="ttname"><a href="../BGL/group___pkg_b_g_l_helper_fct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a></div><div class="ttdeci">bool is_triangle_mesh(const FaceGraph &amp;g)</div></div>
<div class="ttc" id="agroup___pkg_b_g_l_i_o_fct_html_ga49f5b5e6fbfcbfaaac7604c88e10915c"><div class="ttname"><a href="../BGL/group___pkg_b_g_l_i_o_fct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a></div><div class="ttdeci">bool read_polygon_mesh(const std::string &amp;fname, Graph &amp;g, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="anamespace_kernel_html"><div class="ttname"><a href="../Kernel_23/namespace_kernel.html">Kernel</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_shortest_pathExampleWithId"></a>
Example Using Polyhedron_3</h2>
<p>The following example shows how to get the shortest path to every vertex from an arbitrary source point on the surface. Note that this example uses the <code><a class="elRef" href="../BGL/class_c_g_a_l_1_1_polyhedron__items__with__id__3.html">Polyhedron_items_with_id_3</a></code> item class. The shortest path class needs to have an index associated to each vertex, halfedge and face. Using this item class provide an efficient direct access to the required indices.</p>
<p><br>
<b>File</b> <a class="el" href="_surface_mesh_shortest_path_2shortest_paths_with_id_8cpp-example.html">Surface_mesh_shortest_path/shortest_paths_with_id.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_items_with_id_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_surface__mesh__shortest__path_8h.html">CGAL/Surface_mesh_shortest_path.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Polyhedron/class_c_g_a_l_1_1_polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel, CGAL::Polyhedron_items_with_id_3&gt;</a> Triangle_mesh;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path__traits.html">CGAL::Surface_mesh_shortest_path_traits&lt;Kernel, Triangle_mesh&gt;</a> Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html">CGAL::Surface_mesh_shortest_path&lt;Traits&gt;</a> Surface_mesh_shortest_path;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt; Graph_traits;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::vertex_iterator vertex_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_iterator face_iterator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// read input polyhedron</span></div>
<div class="line">  Triangle_mesh tmesh;</div>
<div class="line">  std::ifstream input((argc&gt;1)?argv[1]:CGAL::data_file_path(<span class="stringliteral">"meshes/elephant.off"</span>));</div>
<div class="line">  input &gt;&gt; tmesh;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// initialize indices of vertices, halfedges and faces</span></div>
<div class="line">  <a class="code hl_functionRef" href="../BGL/group___b_g_l_graph_external_indices.html#ga0660924a1aa87e8be5cccbc261e931c7">CGAL::set_halfedgeds_items_id</a>(tmesh);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pick up a random face</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randSeed = argc &gt; 2 ? boost::lexical_cast&lt;unsigned int&gt;(argv[2]) : 7915421;</div>
<div class="line">  CGAL::Random rand(randSeed);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> target_face_index = rand.get_int(0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(num_faces(tmesh)));</div>
<div class="line">  face_iterator face_it = faces(tmesh).first;</div>
<div class="line">  std::advance(face_it,target_face_index);</div>
<div class="line">  <span class="comment">// ... and define a barycentric coordinates inside the face</span></div>
<div class="line">  Traits::Barycentric_coordinates face_location = {{0.25, 0.5, 0.25}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construct a shortest path query object and add a source point</span></div>
<div class="line">  Surface_mesh_shortest_path shortest_paths(tmesh);</div>
<div class="line">  shortest_paths.add_source_point(*face_it, face_location);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// For all vertices in the tmesh, compute the points of</span></div>
<div class="line">  <span class="comment">// the shortest path to the source point and write them</span></div>
<div class="line">  <span class="comment">// into a file readable using CGAL Lab</span></div>
<div class="line">  std::ofstream output(<span class="stringliteral">"shortest_paths_with_id.polylines.txt"</span>);</div>
<div class="line">  vertex_iterator vit, vit_end;</div>
<div class="line">  <span class="keywordflow">for</span> ( boost::tie(vit, vit_end) = vertices(tmesh);</div>
<div class="line">        vit != vit_end; ++vit)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;Traits::Point_3&gt; points;</div>
<div class="line">    shortest_paths.shortest_path_points_to_source_points(*vit, std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print the points</span></div>
<div class="line">    output &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; points.size(); ++i)</div>
<div class="line">      output &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; points[i];</div>
<div class="line">    output &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_polyhedron__3_html"><div class="ttname"><a href="../Polyhedron/class_c_g_a_l_1_1_polyhedron__3.html">CGAL::Polyhedron_3</a></div></div>
<div class="ttc" id="agroup___b_g_l_graph_external_indices_html_ga0660924a1aa87e8be5cccbc261e931c7"><div class="ttname"><a href="../BGL/group___b_g_l_graph_external_indices.html#ga0660924a1aa87e8be5cccbc261e931c7">CGAL::set_halfedgeds_items_id</a></div><div class="ttdeci">void set_halfedgeds_items_id(Polyhedron_with_id &amp;P)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_shortest_pathExampeWithoutId"></a>
Example Using Polyhedron Items without IDs</h2>
<p>Although it is better to have an index built into each simplex, you can also use a surface mesh without internal indices by using external indices. The following example shows how to proceed in this case.</p>
<p><br>
<b>File</b> <a class="el" href="_surface_mesh_shortest_path_2shortest_paths_no_id_8cpp-example.html">Surface_mesh_shortest_path/shortest_paths_no_id.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polyhedron_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_surface__mesh__shortest__path_8h.html">CGAL/Surface_mesh_shortest_path.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>               <a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Polyhedron/class_c_g_a_l_1_1_polyhedron__3.html">CGAL::Polyhedron_3&lt;Kernel&gt;</a>                                        Triangle_mesh;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path__traits.html">CGAL::Surface_mesh_shortest_path_traits&lt;Kernel, Triangle_mesh&gt;</a>    Traits;</div>
<div class="line"><span class="comment">// default property maps</span></div>
<div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangle_mesh,</div>
<div class="line">                            boost::vertex_external_index_t&gt;::const_type   Vertex_index_map;</div>
<div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangle_mesh,</div>
<div class="line">                            CGAL::halfedge_external_index_t&gt;::const_type  Halfedge_index_map;</div>
<div class="line"><span class="keyword">typedef</span> boost::property_map&lt;Triangle_mesh,</div>
<div class="line">                            CGAL::face_external_index_t&gt;::const_type      Face_index_map;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html">CGAL::Surface_mesh_shortest_path</a>&lt;Traits,</div>
<div class="line">                                         Vertex_index_map,</div>
<div class="line">                                         Halfedge_index_map,</div>
<div class="line">                                         Face_index_map&gt;  Surface_mesh_shortest_path;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt; Graph_traits;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::vertex_iterator vertex_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::halfedge_iterator halfedge_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_iterator face_iterator;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  Triangle_mesh tmesh;</div>
<div class="line"> </div>
<div class="line">  std::ifstream input((argc&gt;1)?argv[1]:CGAL::data_file_path(<span class="stringliteral">"meshes/elephant.off"</span>));</div>
<div class="line">  input &gt;&gt; tmesh;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pick up a random face</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randSeed = argc &gt; 2 ? boost::lexical_cast&lt;unsigned int&gt;(argv[2]) : 7915421;</div>
<div class="line">  CGAL::Random rand(randSeed);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> target_face_index = rand.get_int(0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(num_faces(tmesh)));</div>
<div class="line">  face_iterator face_it = faces(tmesh).first;</div>
<div class="line">  std::advance(face_it,target_face_index);</div>
<div class="line">  <span class="comment">// ... and define a barycentric coordinates inside the face</span></div>
<div class="line">  Traits::Barycentric_coordinates face_location = {{0.25, 0.5, 0.25}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construct a shortest path query object and add a source point</span></div>
<div class="line">  <span class="comment">// Note that the external index property map are automatically initialized</span></div>
<div class="line">  Surface_mesh_shortest_path shortest_paths(tmesh,</div>
<div class="line">                                            get(boost::vertex_external_index, tmesh),</div>
<div class="line">                                            get(CGAL::halfedge_external_index, tmesh),</div>
<div class="line">                                            get(CGAL::face_external_index, tmesh),</div>
<div class="line">                                            get(CGAL::vertex_point, tmesh));</div>
<div class="line">  shortest_paths.add_source_point(*face_it, face_location);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// For all vertices in the tmesh, compute the points of</span></div>
<div class="line">  <span class="comment">// the shortest path to the source point and write them</span></div>
<div class="line">  <span class="comment">// into a file readable using CGAL Lab</span></div>
<div class="line">  std::ofstream output(<span class="stringliteral">"shortest_paths_no_id.polylines.txt"</span>);</div>
<div class="line">  vertex_iterator vit, vit_end;</div>
<div class="line">  <span class="keywordflow">for</span> ( boost::tie(vit, vit_end) = vertices(tmesh);</div>
<div class="line">        vit != vit_end; ++vit)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;Traits::Point_3&gt; points;</div>
<div class="line">    shortest_paths.shortest_path_points_to_source_points(*vit, std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print the points</span></div>
<div class="line">    output &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; points.size(); ++i)</div>
<div class="line">      output &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; points[i];</div>
<div class="line">    output &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_shortest_pathMultipleSources"></a>
Using Multiple Source Points</h2>
<p>This example shows how to compute the sequence tree from multiple source points, using an iterator range of <code><a class="el" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a3aa5578369b10a5054ebfaf3bed9e5d0" title="An ordered pair specifying a location on the surface of the Triangle_mesh.">Surface_mesh_shortest_path::Face_location</a></code> objects generated at random.</p>
<p><br>
<b>File</b> <a class="el" href="_surface_mesh_shortest_path_2shortest_paths_multiple_sources_8cpp-example.html">Surface_mesh_shortest_path/shortest_paths_multiple_sources.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_surface__mesh__shortest__path_8h.html">CGAL/Surface_mesh_shortest_path.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iterator&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/class_c_g_a_l_1_1_surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Triangle_mesh;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path__traits.html">CGAL::Surface_mesh_shortest_path_traits&lt;Kernel, Triangle_mesh&gt;</a> Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html">CGAL::Surface_mesh_shortest_path&lt;Traits&gt;</a> Surface_mesh_shortest_path;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_typedef" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a3aa5578369b10a5054ebfaf3bed9e5d0">Surface_mesh_shortest_path::Face_location</a> Face_location;</div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt; Graph_traits;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::vertex_iterator vertex_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_iterator face_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_descriptor face_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/elephant.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Triangle_mesh tmesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group___pkg_b_g_l_i_o_fct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, tmesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group___pkg_b_g_l_helper_fct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(tmesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pick up some source points inside faces,</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randSeed = argc &gt; 2 ? boost::lexical_cast&lt;unsigned int&gt;(argv[2]) : 7915421;</div>
<div class="line">  CGAL::Random rand(randSeed);</div>
<div class="line">  <span class="comment">// by copying the faces in a vector to get a direct access to faces</span></div>
<div class="line">  std::size_t nb_faces=num_faces(tmesh);</div>
<div class="line">  face_iterator fit, fit_end;</div>
<div class="line">  boost::tie(fit, fit_end) = faces(tmesh);</div>
<div class="line">  std::vector&lt;face_descriptor&gt; face_vector(fit, fit_end);</div>
<div class="line">  <span class="comment">// and creating a vector of Face_location objects</span></div>
<div class="line">  <span class="keyword">const</span> std::size_t nb_source_points = 30;</div>
<div class="line">  Traits::Barycentric_coordinates face_location = {{0.25, 0.5, 0.25}};</div>
<div class="line">  std::vector&lt;Face_location&gt; faceLocations(nb_source_points, Face_location(face_descriptor(), face_location));</div>
<div class="line">  <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; nb_source_points; ++i)</div>
<div class="line">  {</div>
<div class="line">    faceLocations[i].first=face_vector[rand.get_int(0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(nb_faces))];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construct a shortest path query object and add a range of source points</span></div>
<div class="line">  Surface_mesh_shortest_path shortest_paths(tmesh);</div>
<div class="line">  shortest_paths.add_source_points(faceLocations.begin(), faceLocations.end());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// For all vertices in the tmesh, compute the points of</span></div>
<div class="line">  <span class="comment">// the shortest path to the source point and write them</span></div>
<div class="line">  <span class="comment">// into a file readable using the CGAL Tmesh demo</span></div>
<div class="line">  std::ofstream output(<span class="stringliteral">"shortest_paths_multiple_sources.polylines.txt"</span>);</div>
<div class="line">  vertex_iterator vit, vit_end;</div>
<div class="line">  <span class="keywordflow">for</span> ( boost::tie(vit, vit_end) = vertices(tmesh);</div>
<div class="line">        vit != vit_end; ++vit)</div>
<div class="line">  {</div>
<div class="line">    std::vector&lt;Traits::Point_3&gt; points;</div>
<div class="line">    shortest_paths.shortest_path_points_to_source_points(*vit, std::back_inserter(points));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// print the points</span></div>
<div class="line">    output &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" "</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; points.size(); ++i)</div>
<div class="line">      output &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; points[i];</div>
<div class="line">    output &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_surface__mesh__shortest__path_html_a3aa5578369b10a5054ebfaf3bed9e5d0"><div class="ttname"><a href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a3aa5578369b10a5054ebfaf3bed9e5d0">CGAL::Surface_mesh_shortest_path::Face_location</a></div><div class="ttdeci">std::pair&lt; face_descriptor, Barycentric_coordinates &gt; Face_location</div><div class="ttdoc">An ordered pair specifying a location on the surface of the Triangle_mesh.</div><div class="ttdef"><b>Definition:</b> Surface_mesh_shortest_path.h:151</div></div>
</div><!-- fragment --><h2><a class="anchor" id="Surface_mesh_shortest_pathSequenceVisitor"></a>
Shortest Path Sequence Visitor</h2>
<p>This example shows how to implement a model of the <code><a class="el" href="class_surface_mesh_shortest_path_visitor.html" title="The concept SurfaceMeshShortestPathVisitor describes the requirements of the visitor type used to col...">SurfaceMeshShortestPathVisitor</a></code> concept to get detailed information about the sequence of simplicies crossed by a shortest path.</p>
<p><br>
<b>File</b> <a class="el" href="_surface_mesh_shortest_path_2shortest_path_sequence_8cpp-example.html">Surface_mesh_shortest_path/shortest_path_sequence.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Random.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Surface_mesh.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_surface__mesh__shortest__path_8h.html">CGAL/Surface_mesh_shortest_path.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;variant&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;boost/lexical_cast.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;cstdlib&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> <a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Surface_mesh/class_c_g_a_l_1_1_surface__mesh.html">CGAL::Surface_mesh&lt;Kernel::Point_3&gt;</a> Triangle_mesh;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path__traits.html">CGAL::Surface_mesh_shortest_path_traits&lt;Kernel, Triangle_mesh&gt;</a> Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html">CGAL::Surface_mesh_shortest_path&lt;Traits&gt;</a> Surface_mesh_shortest_path;</div>
<div class="line"><span class="keyword">typedef</span> Traits::Barycentric_coordinates Barycentric_coordinates;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> boost::graph_traits&lt;Triangle_mesh&gt; Graph_traits;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::vertex_iterator vertex_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_iterator face_iterator;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::vertex_descriptor vertex_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::face_descriptor face_descriptor;</div>
<div class="line"><span class="keyword">typedef</span> Graph_traits::halfedge_descriptor halfedge_descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A model of SurfacemeshShortestPathVisitor storing simplicies</span></div>
<div class="line"><span class="comment">// using std::variant</span></div>
<div class="line"><span class="keyword">struct </span>Sequence_collector</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> std::variant&lt; vertex_descriptor,</div>
<div class="line">                         std::pair&lt;halfedge_descriptor,double&gt;,</div>
<div class="line">                         std::pair&lt;face_descriptor, Barycentric_coordinates&gt; &gt; Simplex;</div>
<div class="line">  std::vector&lt; Simplex &gt; sequence;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(halfedge_descriptor he, <span class="keywordtype">double</span> alpha)</div>
<div class="line">  {</div>
<div class="line">    sequence.push_back(std::make_pair(he, alpha));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(vertex_descriptor v)</div>
<div class="line">  {</div>
<div class="line">    sequence.push_back(v);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(face_descriptor f, Barycentric_coordinates alpha)</div>
<div class="line">  {</div>
<div class="line">    sequence.push_back(std::make_pair(f, alpha));</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A visitor to print what a variant contains using std::visit</span></div>
<div class="line"><span class="keyword">struct </span>Print_visitor</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> i;</div>
<div class="line">  Triangle_mesh&amp; g;</div>
<div class="line"> </div>
<div class="line">  Print_visitor(Triangle_mesh&amp; g) :i(-1), g(g) {}</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(vertex_descriptor v)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"#"</span> &lt;&lt; ++i &lt;&lt; <span class="stringliteral">" Vertex: "</span> &lt;&lt; get(boost::vertex_index, g)[v];</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Position: "</span> &lt;&lt; Surface_mesh_shortest_path::point(v, g) &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> std::pair&lt;halfedge_descriptor,double&gt;&amp; h_a)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"#"</span> &lt;&lt; ++i &lt;&lt; <span class="stringliteral">" Edge: "</span> &lt;&lt; get(CGAL::halfedge_index, g)[h_a.first] &lt;&lt; <span class="stringliteral">" , ("</span></div>
<div class="line">                                           &lt;&lt; 1.0 - h_a.second &lt;&lt; <span class="stringliteral">" , "</span></div>
<div class="line">                                           &lt;&lt; h_a.second &lt;&lt; <span class="stringliteral">")"</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Position: "</span> &lt;&lt; Surface_mesh_shortest_path::point(h_a.first, h_a.second, g) &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> std::pair&lt;face_descriptor, Barycentric_coordinates&gt;&amp; f_bc)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"#"</span> &lt;&lt; ++i &lt;&lt; <span class="stringliteral">" Face: "</span> &lt;&lt; get(CGAL::face_index, g)[f_bc.first] &lt;&lt; <span class="stringliteral">" , ("</span></div>
<div class="line">                                           &lt;&lt; f_bc.second[0] &lt;&lt; <span class="stringliteral">" , "</span></div>
<div class="line">                                           &lt;&lt; f_bc.second[1] &lt;&lt; <span class="stringliteral">" , "</span></div>
<div class="line">                                           &lt;&lt; f_bc.second[2] &lt;&lt; <span class="stringliteral">")"</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">" Position: "</span> &lt;&lt; Surface_mesh_shortest_path::point(f_bc.first, f_bc.second, g) &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc&gt;1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"meshes/elephant.off"</span>);</div>
<div class="line"> </div>
<div class="line">  Triangle_mesh tmesh;</div>
<div class="line">  <span class="keywordflow">if</span>(!<a class="code hl_functionRef" href="../BGL/group___pkg_b_g_l_i_o_fct.html#ga49f5b5e6fbfcbfaaac7604c88e10915c">CGAL::IO::read_polygon_mesh</a>(filename, tmesh) ||</div>
<div class="line">     !<a class="code hl_functionRef" href="../BGL/group___pkg_b_g_l_helper_fct.html#ga11883d231eec1b58f37efe4acedd9588">CGAL::is_triangle_mesh</a>(tmesh))</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pick up a random face</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> randSeed = argc &gt; 2 ? boost::lexical_cast&lt;unsigned int&gt;(argv[2]) : 7915421;</div>
<div class="line">  CGAL::Random rand(randSeed);</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> target_face_index = rand.get_int(0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(num_faces(tmesh)));</div>
<div class="line">  face_iterator face_it = faces(tmesh).first;</div>
<div class="line">  std::advance(face_it,target_face_index);</div>
<div class="line">  <span class="comment">// ... and define a barycentric coordinates inside the face</span></div>
<div class="line">  Barycentric_coordinates face_location = {{0.25, 0.5, 0.25}};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construct a shortest path query object and add a source point</span></div>
<div class="line">  Surface_mesh_shortest_path shortest_paths(tmesh);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Add source: "</span> &lt;&lt; <a class="code hl_function" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a5414e54d0df418a0d7f00c4650995031">Surface_mesh_shortest_path::point</a>(*face_it, face_location, tmesh) &lt;&lt; std::endl;</div>
<div class="line">  shortest_paths.add_source_point(*face_it, face_location);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// pick a random target point inside a face</span></div>
<div class="line">  face_it = faces(tmesh).first;</div>
<div class="line">  std::advance(face_it, rand.get_int(0, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(num_faces(tmesh))));</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Target is: "</span> &lt;&lt; <a class="code hl_function" href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a5414e54d0df418a0d7f00c4650995031">Surface_mesh_shortest_path::point</a>(*face_it, face_location, tmesh) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// collect the sequence of simplicies crossed by the shortest path</span></div>
<div class="line">  Sequence_collector sequence_collector;</div>
<div class="line">  shortest_paths.shortest_path_sequence_to_source_points(*face_it, face_location, sequence_collector);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// print the sequence using the visitor pattern</span></div>
<div class="line">  Print_visitor print_visitor(tmesh);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; sequence_collector.sequence.size(); ++i)</div>
<div class="line">    std::visit(print_visitor, sequence_collector.sequence[i]);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_surface__mesh__shortest__path_html_a5414e54d0df418a0d7f00c4650995031"><div class="ttname"><a href="class_c_g_a_l_1_1_surface__mesh__shortest__path.html#a5414e54d0df418a0d7f00c4650995031">CGAL::Surface_mesh_shortest_path::point</a></div><div class="ttdeci">Point_3 point(const face_descriptor f, const Barycentric_coordinates &amp;location) const</div><div class="ttdoc">returns the 3-dimensional coordinates at the barycentric coordinates of the given face.</div><div class="ttdef"><b>Definition:</b> Surface_mesh_shortest_path.h:2742</div></div>
</div><!-- fragment --><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>add an example using the AABB-tree</dd></dl>
<h1><a class="anchor" id="Surface_mesh_shortest_pathBenchmarks"></a>
Benchmarks</h1>
<p>These benchmarks were run using randomly generated source and destination points over multiple trials. The measurements were executed using CGAL 4.5, under Cygwin 1.7.32, using the Gnu C++ compiler version 4.8.3 with options <code>-O3 -DNDEBUG</code>. The system used was a 64bit Intel Core i3 2.20GHz processor with 6GB of RAM</p>
<h2><a class="anchor" id="Surface_mesh_shortest_pathBenchmark1SourcePoint"></a>
Single Source Point</h2>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Model   </th><th class="markdownTableHeadNone">Number of Vertices   </th><th class="markdownTableHeadNone">Average Construction Time (s)   </th><th class="markdownTableHeadNone">Average Queries Per Second   </th><th class="markdownTableHeadNone">Peak Memory Usage (MB)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ellipsoid.off   </td><td class="markdownTableBodyNone">162   </td><td class="markdownTableBodyNone">0.00258805   </td><td class="markdownTableBodyNone">1.21972e+06   </td><td class="markdownTableBodyNone">0.39548    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">anchor.off   </td><td class="markdownTableBodyNone">519   </td><td class="markdownTableBodyNone">0.0580262   </td><td class="markdownTableBodyNone">230461   </td><td class="markdownTableBodyNone">3.88799    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rotor.off   </td><td class="markdownTableBodyNone">600   </td><td class="markdownTableBodyNone">0.0386633   </td><td class="markdownTableBodyNone">326175   </td><td class="markdownTableBodyNone">3.10571    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">spool.off   </td><td class="markdownTableBodyNone">649   </td><td class="markdownTableBodyNone">0.0418305   </td><td class="markdownTableBodyNone">299766   </td><td class="markdownTableBodyNone">3.75773    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">handle.off   </td><td class="markdownTableBodyNone">1165   </td><td class="markdownTableBodyNone">0.0976167   </td><td class="markdownTableBodyNone">227343   </td><td class="markdownTableBodyNone">7.66706    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">couplingdown.off   </td><td class="markdownTableBodyNone">1841   </td><td class="markdownTableBodyNone">0.138467   </td><td class="markdownTableBodyNone">246833   </td><td class="markdownTableBodyNone">10.1731    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bones.off   </td><td class="markdownTableBodyNone">2154   </td><td class="markdownTableBodyNone">0.0101125   </td><td class="markdownTableBodyNone">1.31834e+06   </td><td class="markdownTableBodyNone">0.865896    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mushroom.off   </td><td class="markdownTableBodyNone">2337   </td><td class="markdownTableBodyNone">0.206034   </td><td class="markdownTableBodyNone">202582   </td><td class="markdownTableBodyNone">22.5804    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">elephant.off   </td><td class="markdownTableBodyNone">2775   </td><td class="markdownTableBodyNone">0.136177   </td><td class="markdownTableBodyNone">313785   </td><td class="markdownTableBodyNone">14.0987    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cow.off   </td><td class="markdownTableBodyNone">2904   </td><td class="markdownTableBodyNone">0.259104   </td><td class="markdownTableBodyNone">206515   </td><td class="markdownTableBodyNone">17.4796    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">knot1.off   </td><td class="markdownTableBodyNone">3200   </td><td class="markdownTableBodyNone">0.279455   </td><td class="markdownTableBodyNone">207084   </td><td class="markdownTableBodyNone">25.314    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">retinal.off   </td><td class="markdownTableBodyNone">3643   </td><td class="markdownTableBodyNone">0.255788   </td><td class="markdownTableBodyNone">247617   </td><td class="markdownTableBodyNone">29.8031    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">femur.off   </td><td class="markdownTableBodyNone">3897   </td><td class="markdownTableBodyNone">0.25332   </td><td class="markdownTableBodyNone">264825   </td><td class="markdownTableBodyNone">21.4806    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">knot2.off   </td><td class="markdownTableBodyNone">5760   </td><td class="markdownTableBodyNone">0.295655   </td><td class="markdownTableBodyNone">309593   </td><td class="markdownTableBodyNone">22.5549    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bull.off   </td><td class="markdownTableBodyNone">6200   </td><td class="markdownTableBodyNone">0.513506   </td><td class="markdownTableBodyNone">209994   </td><td class="markdownTableBodyNone">34.983    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fandisk.off   </td><td class="markdownTableBodyNone">6475   </td><td class="markdownTableBodyNone">0.609507   </td><td class="markdownTableBodyNone">198768   </td><td class="markdownTableBodyNone">71.3617    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lion-head.off   </td><td class="markdownTableBodyNone">8356   </td><td class="markdownTableBodyNone">1.23863   </td><td class="markdownTableBodyNone">145810   </td><td class="markdownTableBodyNone">86.6908    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">turbine.off   </td><td class="markdownTableBodyNone">9210   </td><td class="markdownTableBodyNone">2.23755   </td><td class="markdownTableBodyNone">93079.5   </td><td class="markdownTableBodyNone">172.072    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">man.off   </td><td class="markdownTableBodyNone">17495   </td><td class="markdownTableBodyNone">1.59015   </td><td class="markdownTableBodyNone">187519   </td><td class="markdownTableBodyNone">148.358   </td></tr>
</table>
</center><h2><a class="anchor" id="Surface_mesh_shortest_pathBenchmark10SourcePoints"></a>
Ten Source Points</h2>
<center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Model   </th><th class="markdownTableHeadNone">Number of Vertices   </th><th class="markdownTableHeadNone">Average Construction Time (s)   </th><th class="markdownTableHeadNone">Average Queries Per Second   </th><th class="markdownTableHeadNone">Peak Memory Usage (MB)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ellipsoid.off   </td><td class="markdownTableBodyNone">162   </td><td class="markdownTableBodyNone">0.00321017   </td><td class="markdownTableBodyNone">911025   </td><td class="markdownTableBodyNone">0.245674    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">anchor.off   </td><td class="markdownTableBodyNone">519   </td><td class="markdownTableBodyNone">0.03601   </td><td class="markdownTableBodyNone">353062   </td><td class="markdownTableBodyNone">3.19274    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rotor.off   </td><td class="markdownTableBodyNone">600   </td><td class="markdownTableBodyNone">0.015864   </td><td class="markdownTableBodyNone">805416   </td><td class="markdownTableBodyNone">1.97554    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">spool.off   </td><td class="markdownTableBodyNone">649   </td><td class="markdownTableBodyNone">0.0165743   </td><td class="markdownTableBodyNone">802701   </td><td class="markdownTableBodyNone">2.09675    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">handle.off   </td><td class="markdownTableBodyNone">1165   </td><td class="markdownTableBodyNone">0.0294564   </td><td class="markdownTableBodyNone">646057   </td><td class="markdownTableBodyNone">4.62122    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">couplingdown.off   </td><td class="markdownTableBodyNone">1841   </td><td class="markdownTableBodyNone">0.126045   </td><td class="markdownTableBodyNone">272465   </td><td class="markdownTableBodyNone">7.80517    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bones.off   </td><td class="markdownTableBodyNone">2154   </td><td class="markdownTableBodyNone">0.055434   </td><td class="markdownTableBodyNone">536646   </td><td class="markdownTableBodyNone">4.0203    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mushroom.off   </td><td class="markdownTableBodyNone">2337   </td><td class="markdownTableBodyNone">0.139285   </td><td class="markdownTableBodyNone">290425   </td><td class="markdownTableBodyNone">11.462    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">elephant.off   </td><td class="markdownTableBodyNone">2775   </td><td class="markdownTableBodyNone">0.167269   </td><td class="markdownTableBodyNone">285076   </td><td class="markdownTableBodyNone">11.2743    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">cow.off   </td><td class="markdownTableBodyNone">2904   </td><td class="markdownTableBodyNone">0.15432   </td><td class="markdownTableBodyNone">328549   </td><td class="markdownTableBodyNone">13.0676    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">knot1.off   </td><td class="markdownTableBodyNone">3200   </td><td class="markdownTableBodyNone">0.114051   </td><td class="markdownTableBodyNone">454640   </td><td class="markdownTableBodyNone">16.1735    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">retinal.off   </td><td class="markdownTableBodyNone">3643   </td><td class="markdownTableBodyNone">0.233208   </td><td class="markdownTableBodyNone">287869   </td><td class="markdownTableBodyNone">18.6274    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">femur.off   </td><td class="markdownTableBodyNone">3897   </td><td class="markdownTableBodyNone">0.128097   </td><td class="markdownTableBodyNone">457112   </td><td class="markdownTableBodyNone">16.8295    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">knot2.off   </td><td class="markdownTableBodyNone">5760   </td><td class="markdownTableBodyNone">0.413548   </td><td class="markdownTableBodyNone">260195   </td><td class="markdownTableBodyNone">33.484    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">bull.off   </td><td class="markdownTableBodyNone">6200   </td><td class="markdownTableBodyNone">0.371713   </td><td class="markdownTableBodyNone">297560   </td><td class="markdownTableBodyNone">30.522    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">fandisk.off   </td><td class="markdownTableBodyNone">6475   </td><td class="markdownTableBodyNone">0.545929   </td><td class="markdownTableBodyNone">223865   </td><td class="markdownTableBodyNone">39.5607    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">lion-head.off   </td><td class="markdownTableBodyNone">8356   </td><td class="markdownTableBodyNone">0.70097   </td><td class="markdownTableBodyNone">229449   </td><td class="markdownTableBodyNone">59.6597    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">turbine.off   </td><td class="markdownTableBodyNone">9210   </td><td class="markdownTableBodyNone">1.35703   </td><td class="markdownTableBodyNone">157301   </td><td class="markdownTableBodyNone">90.7139    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">man.off   </td><td class="markdownTableBodyNone">17495   </td><td class="markdownTableBodyNone">1.75936   </td><td class="markdownTableBodyNone">185194   </td><td class="markdownTableBodyNone">122.541   </td></tr>
</table>
</center><h2><a class="anchor" id="Surface_mesh_shortest_pathQueryComparison"></a>
Comparison of Construction and Query Times with Multiple Source Points</h2>
<p>The following figures track the construction time, query time, and peak memory usage for the various test models as the number of source points increases. Notice that none of the values increases significantly as the number of source points increases. In fact, in most cases, the running time and memory go down. This is because a larger number of source points tends to result in a more flat sequence tree, which translates to reduced runtime and memory costs.</p>
<p><a class="anchor" id="fig__Benchmark_construction"></a> </p><div class="image">
<img src="benchmark_plot_construction.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Benchmark_construction">Figure 77.2</a> Plot of construction times against different numbers of source points. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__Benchmark_query"></a> </p><div class="image">
<img src="benchmark_plot_query.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Benchmark_query">Figure 77.3</a> Plot of query times against different numbers of source points. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__Benchmark_memory"></a> </p><div class="image">
<img src="benchmark_plot_memory.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Benchmark_memory">Figure 77.4</a> Plot of peak memory usage against different numbers of source points. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="Surface_mesh_shortest_pathTheory"></a>
Implementation Details</h1>
<h2><a class="anchor" id="Surface_mesh_shortest_pathDefinitions"></a>
Definitions</h2>
<h3><a class="anchor" id="Surface_mesh_shortest_pathGeodesics"></a>
Geodesic Paths</h3>
<p>A <em>geodesic</em> curve is a <em>locally shortest</em> path on the surface of some manifold, that is, it cannot be made shorter by some local perturbations. On a surface mesh, this translates to a curve where, when the faces crossed by the curve are unfolded into the plane, the curve forms a straight line. Another way of describing it is that there is exactly \(\pi\) surface angle to both sides at every point along the curve (except possibly at the curve's endpoints).</p>
<p>A geodesic curve between two points is not necessarily a shortest path, but all shortest paths on surface meshes are formed by sequences of one or more geodesic paths, whose junction points are either vertices on the boundary of the mesh, or <a class="el" href="index.html#Surface_mesh_shortest_pathSaddleVertex"><em>saddle vertices</em></a>. We call such a curve on the surface of the mesh a <em>potential shortest path</em> between its two endpoints.</p>
<p><a class="anchor" id="fig__Geodesic_perspective"></a> </p><div class="image">
<img src="perspectiveGeodesic.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Geodesic_perspective">Figure 77.5</a> A geodesic on the surface of a simple surface mesh. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__Geodesic_unrolled"></a> </p><div class="image">
<img src="unrolledGeodesic.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Geodesic_unrolled">Figure 77.6</a> The same geodesic, with its faces unfolded into the plane. Note in the unfolding, the geodesic forms a straight line. </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathVisibilityWindow"></a>
Visibility Window</h3>
<p>A <em>visibility window</em> (or <em>visibility cone</em>) is a pair of geodesic curves which share a common <em>source point</em> and enclose a <em>locally flat</em> region of the surface mesh. Locally flat means that between every pair of points inside the window, there is exactly one geodesic path between them which also stays inside the bounds of the window. Thus, operations, such as distance calculations, can be done with normal 2D Euclidean operations while inside the window. When a visibility window encounters a vertex (a non-flat part of the surface), a <em>branch</em> occurs, forming a sub-window to either side.</p>
<p><a class="anchor" id="fig__Visibility_window_1"></a> </p><div class="image">
<img src="visibilityCone-1.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Visibility_window_1">Figure 77.7</a> A single visibility window, before it encounters a vertex. </p> </div> <p> <br>
</p>
<p><a class="anchor" id="fig__Visibility_window_2"></a> </p><div class="image">
<img src="visibilityCone-2.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Visibility_window_2">Figure 77.8</a> After encountering a convex vertex, the visibility window branches to either side (blue on the left, red on the right). Note that the two new windows immediately overlap on the other side of the vertex, since the surrounding surface area is less than \(2 \pi\). Points inside this region of overlap might have two possible shortest paths from the origin point. </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathSaddleVertex"></a>
Saddle Vertices</h3>
<p>A <em>saddle vertex</em> on a surface mesh is a vertex \(v\) where the sum of surface angles of all faces incident at \(v\) is greater than \(2 \pi\), or, in simpler terms, one cannot flatten all the faces incident to \(v\) into the plane without overlap. Identifying and dealing with saddle vertices are important in shortest path algorithms because they form <em>blind spots</em> which cannot be reached by a single geodesic curve.</p>
<p><a class="anchor" id="fig__Saddle_vertex"></a> </p><div class="image">
<img src="saddleVertex.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Saddle_vertex">Figure 77.9</a> A visibility window (shaded blue) encounters a saddle vertex; the shaded red region behind the vertex is not reachable by a geodesic curve from the source point (assuming the geodesic must stay inside the initial window). </p> </div> <p> <br>
</p>
<p>In order to deal with this, we must create a new set of child visibility windows which branch out around the saddle vertex. The paths through these child windows would first arrive at the saddle vertex, and then follow a new visibility window (forming a kind of poly-line on the surface). Note that similar behavior is required when we reach a boundary vertex of a non-closed surface mesh.</p>
<p><a class="anchor" id="fig__Saddle_vertex_expand"></a> </p><div class="image">
<img src="saddleVertexExpand.png" alt="">
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__Saddle_vertex_expand">Figure 77.10</a> In order to see past the <em>blind spot</em> created by the saddle vertex, we create a branching set of visibility windows emanating from the saddle vertex. Note that only the branches which cover the <em>blind spot</em> for the parent visibility window are needed for our algorithm. </p> </div> <p> <br>
</p>
<h3><a class="anchor" id="Surface_mesh_shortest_pathSequenceTree"></a>
The Sequence Tree</h3>
<p>In order to compute shortest paths, we build a <em>sequence tree</em> (or <em>cone tree</em>) from each source point. The sequence tree describes the combinatoric structure of all <em>potential shortest paths</em> which originate from a single source point, by organizing them into a hierarchy of visibility windows.</p>
<p>Whenever a vertex of the surface mesh is encountered, a branch occurs in the sequence tree. If the vertex is a non-saddle vertex, then only two children are created, one for each edge incident to that vertex on the current face. If the vertex is a saddle vertex, in addition to the two children mentioned above, a special type of node, called a <em>pseudo-source</em>, is created which branches out from that vertex.</p>
<p>Once a sequence tree is built, the <em>potential shortest paths</em> from the source to every point inside a given visibility window can be computed. The sequence of faces along each branch of the tree are laid out edge to edge, into a common plane, such that the geodesic distance from any point on the surface to its nearest source point can be obtained using a single 2D Euclidean distance computation. Note that if the window belongs to a pseudo-source, the distance is measured from the target to the pseudo-source, and then the distance from the pseudo-source back to its parent is measured, and so on back to the original source.</p>
<h2><a class="anchor" id="Surface_mesh_shortest_pathAlgorithmOverview"></a>
Algorithm Overview</h2>
<p>The size of the sequence tree from any source point is theoretically infinite, however we only ever care about trees which are of depth at most N, where N is the number of faces in the surface mesh (since no shortest path can cross the same face twice). Even then, the size of this truncated sequence tree is potentially exponential in the size of the surface mesh, thus a simple breadth-first search is not feasible. Rather, we apply techniques to eliminate entire branches which are provably unable to contain shortest paths from the source point(s). The techniques used are given in greater detail in a paper by Xin and Wang <a class="el" href="citelist.html#CITEREF_XinWang2009improvingchenandhan">[3]</a>, which itself expands an earlier work by Chen and Han <a class="el" href="citelist.html#CITEREF_ch-spp-96">[1]</a> and Mitchell, Mount, and Papadimitriou <a class="el" href="citelist.html#CITEREF_mmp-dgp-87">[2]</a> .</p>
<p>Handling multiple source points is simply a matter of constructing multiple sequence trees concurrently, using a method similar to the multi-source Dijsktra's algorithm.</p>
<h2><a class="anchor" id="Surface_mesh_shortest_pathContinuousDijkstra"></a>
Continuous Dijkstra</h2>
<p>Continuous Dijkstra is simply the application of the graph-search algorithm to a non-discrete setting. As we build the search tree, newly created nodes are tagged with a distance metric, and inserted into a priority queue, such that the shortest distance nodes are always first.</p>
<h2><a class="anchor" id="Surface_mesh_shortest_pathOneAngleOneSplit"></a>
One Angle, One Split</h2>
<p>This observation by Chen and Han states that out of all the branches that occur at any given vertex of the surface mesh, only a limited number have more than one child which can define shortest paths. This is accomplished by maintaining, for each vertex, all nodes of the sequence tree which can contain that vertex inside their visibility window.</p>
<ul>
<li>For each vertex, only <em>one</em> two-way branch may occur per face incident to that vertex, specifically, that of the nearest node to that vertex which crosses that face. We call that closest node the <em>occupier</em> of that vertex.</li>
<li>If the vertex is a saddle vertex, only one pseudo-source may be established at that vertex, this time by the absolute nearest node to that vertex.</li>
</ul>
<p>This method alone can decrease the running time for construction of the sequence tree construction to polynomial time.</p>
<h2><a class="anchor" id="Surface_mesh_shortest_pathDistanceFiltering"></a>
Distance Filtering</h2>
<p>An additional distance filter proposed by Xin and Wang helps prune the search tree even further by comparing the current node's distance to the closest distance so far of the three vertices on the current face. Details on this method can be found in their paper <a class="el" href="citelist.html#CITEREF_XinWang2009improvingchenandhan">[3]</a>.</p>
<h2><a class="anchor" id="Surface_mesh_shortest_pathLocatingShortestPaths"></a>
Locating Shortest Paths</h2>
<p>In order to locate the shortest path from a target point to a source point, we must select the correct visibility window. A simple method is to keep track for each face \(f\) of all windows which cross \(f\). In practice, at most a constant number of windows will cross any given face, so for simplicity this is the method we employ. An alternative is to construct a Voronoi-like structure on each face, where each cell represents a visibility window. We did not attempt this method, however it would seem likely that it would be of no computational benefit.</p>
<h2><a class="anchor" id="Pseudo-Code"></a>
Pseudo-Code</h2>
<p>In this section we give a brief outline of the pseudo-code for this algorithm. More details can be found in <a class="el" href="citelist.html#CITEREF_ch-spp-96">[1]</a> and <a class="el" href="citelist.html#CITEREF_XinWang2009improvingchenandhan">[3]</a>.</p>
<pre class="fragment">--
-- Global Values
--
G : FaceGraph(V,E,F)
  -- V - the set of vertices
  -- E - the set of edges
  -- F - the set of planar faces

Q : PriorityQueue
  -- A priority queue ordered using the metric given by Xin and Wang

--
-- Types
--
type VisbilityWindow:
  f : a face of F, the current face of this window, we say this window 'crosses' face f
  s : a point on the surface of F, the source point of this window
  d :  the 'base distance' to s, only non-zero if s is a pseudo-source
  l : the left-side bounding ray of this window, with its origin at s
  r : the right-side bounding ray of this window, with its origin at s
  p : its parent VisibilityWindow

--
-- Methods
--
method XinWangDistanceFilter:
  Input:
    w : a VisibilityWindow
  Output:
    filter : true if w passes the distance filtering metric given by Xin and Wang, false otherwise

method PropagateWindow:
  Input:
    w : a visibility window
    e : an edge on face w.f
  Output:
    w' : A new visibility window on the face opposite w.f across edge e
  Begin:
    Let f' be the face on the opposite side of e as w.f
    Lay out face f' along e, such that it shares a common plane with w.f
    Create a new VisibilityWindow w', with
    - w its parent
    - the same source point and base distance as w
    - its boundary rays clipped to the sub-segment of e covered by w
    return w'

method CreateFaceWindow:
  Input:
    f : a face of F
    v : a vertex of f
    w : a VisibilityWindow which intersects f and contains v
  Output:
    w' : a new VisibilityWindow, with
    -- w its parent
    -- its source point s = v
    -- its two bounding rays along the edges incident to v
    -- face f as its crossed face
    -- its base distance being the distance of window w to v

method CreatePseudoSource:
  Input:
    w : the parent window
    v : a saddle vertex of V
  Begin:
    For each face f incident to v:
      w' = CreateFaceWindow(f, v, w)
      Q.insert(w')

method TreeDepth:
  Input:
    w : a VisibilityWindow in some sequence tree T
  Output:
    The depth of node w in its current sequence tree (this would typically be cached in w itself)

method ShortestPathTree:
  Input:
    s[1..n] : a set of source points on the surface of G.
              For simplicity (and without loss of generality),
              we will assume they are all vertices of G.
  Output:
    T[1..n] : a set of sequence trees for the source points
  Declare:
    O : a map of (f,v) =&gt; VisibilityWindow, which gives the 'vertex occupier' for (f,v),
        that is the window which crosses face f and whose source is nearest to vertex v
    S : a map of v =&gt; VisibilityWindow, which gives the window whose source is nearest
        to v. Note that this is a strict subset of O
  Begin:
    for i in 1..n:
      Let r[i] be the root of T[i], with distance 0 to s[i]
      CreatePseudoSource( r[i], s[i] )
    While Q is not empty:
      w = Q.take()
      if XinWangDistanceFilter(w) and TreeDepth(w) &lt;= |F|:
        if w contains a vertex v of w.f:
          if w is closer to v than O[w.f,v]:
            O[w.f,v] = w
            if v is a boundary vertex or a saddle vertex, and w is closer to v than S[v]:
              S[v] = w
              CreatePseudoSource(w, v, w.dist(v))
            let {e_0, e_1} be the edges of f incident to v
            for i in [0,1]:
              w' = PropagateWindow(w, e_i)
              Q.insert(w')
          else:
            let e_n be the edge 'closer' to window w
            w' = PropagateWindow(w, e_n)
            Q.insert(w')
        else:
          let e_o be the only edge crossed by window w
          w' = PropagateWindow(w, e_o)
          Q.insert(w')
    return T[1..n]
</pre><p>To perform shortest path distance queries to each vertex, we can simply use the results stored in <code>S</code> after the completion of ShortestPathTree, as it contains a map from each vertex to the <code>VisibilityWindow</code> which has the shortest path to that vertex. Performing shortest path computations to any arbitrary face location is slightly more complex. As eluded to above, after completion of the algorithm, we traverse each of the sequence trees, and for each face <code>f</code> we store all the VisibilityWindows which cross <code>f</code> in a look-up structure. Then, to find the shortest path to a point on the surface of face <code>f</code>, we look up that pre-stored set of VisibilityWindows associated with it, and among those windows we select the one which contains the query point and has the shortest path back to the origin. Though it may seem slow since it involves a linear search but it is efficient in practice since the number of faces crossing any single face is typically limited (this is due to the additional filtering method given by Xin and Wang <a class="el" href="citelist.html#CITEREF_XinWang2009improvingchenandhan">[3]</a>.</p>
<p>The actual surface paths can be reconstructed by backtracking from the VisibilityWindow, through its parents in the tree up to the root, and keeping track of each face that was crossed.</p>
<h1><a class="anchor" id="Surface_mesh_shortest_pathImplementationhistory"></a>
Design and Implementation History</h1>
<p>This package is the result of the work of Stephen Kiazyk during the 2014 season of the Google Summer of Code. He has been mentored by Sébastien Loriot and Éric Colin de Verdière who also contributed to the documentation and the API definition. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
