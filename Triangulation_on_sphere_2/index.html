<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Triangulation_on_sphere_2/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - 2D Triangulations on the Sphere: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"> 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - 2D Triangulations on the Sphere
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_2D_Triangulations_on_sphere"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Mael Rouxel-Labbé, Monique Teillaud, and Claudia Werner</dd></dl>
<p><a class="anchor" id="fig__fig_TOS2_header"></a></p><center> <img src="header.png" alt="" style="max-width:70%;" class="inline"> </center><p>This chapter describes two-dimensional triangulations on the sphere. It is organized as follows: </p><ul>
<li>
Section <a class="el" href="index.html#Section_2D_ToS_Definitions">Definitions</a> introduces the main definitions about triangulations on the sphere. </li>
<li>
Section <a class="el" href="index.html#Section_2D_ToS_Implementation">Implementation</a> details the way two-dimensional triangulations on the sphere are implemented and represented in CGAL. </li>
<li>
Section <a class="el" href="index.html#Section_2D_ToS_Examples">Examples</a> lists a few basic examples to illustrate the capabilities of the package. </li>
</ul>
<h1><a class="anchor" id="Section_2D_ToS_Definitions"></a>
Definitions</h1>
<p>Denote by \( \mathbb{S(c, r)}\) the two-dimensional sphere embedded in the Euclidean space \( \mathbb{R}^3\), with center <code>c</code> and radius <code>r</code>, that is \( \mathbb{S(c, r)} = \left\{ x \in \mathbf{R}^3 : \left\| x - c \right\| = r \right\} \). When the parameters <code>c</code> and <code>r</code> are not important, they will be omitted and \( \mathbb{S}\) will be used directly. Given a set \( \mathcal{P}\) of points on \( \mathbb{S(c, r)}\), a <em>two-dimension triangulation</em> of \( \mathcal{P}\) can be described as a two-dimensional simplicial complex that is pure, connected, and without singularity whose vertices are exactly the points in \( \mathcal{P}\) (see the complete definition in the package <a class="elRef" href="../Triangulation_2/index.html#Section_2D_Triangulations_Definitions">2D Triangulations</a>).</p>
<p>In \( \mathbb{R}^2\), a <em>Delaunay</em> triangulation is a two-dimension triangulation that satisfies the <em>empty circle property</em> (also called <em>Delaunay property</em>): the circumscribing circle of any facet of the triangulation contains no point in its interior. This definition naturally extends to the two-dimensional sphere, as illustrated in the figure below.</p>
<p><a class="anchor" id="fig__fig_del_def"></a> </p><div class="image">
<object type="image/svg+xml" data="delaunay_on_sphere_def.svg" style="pointer-events: none;"></object>
</div>
   <div class="cgal_figure_caption"> <p>  <a class="el" href="index.html#fig__fig_del_def">Figure 42.2</a> Delaunay property: the circumscribing circle (in green) on the sphere of the Delaunay face \( p_1 p_2 p_3\) is empty. </p> </div> <p> <br>
</p>
<p>A particularity of Delaunay triangulations on \( \mathbb{S}\) is that the Delaunay property test can be reduced to a simple orientation test in the three-dimensional space: indeed, the circumscribing circle of a Delaunay face is the intersection of the plane passing through the three vertices of the face with \( \mathbb{S}\), and determining whether a fourth point <code>q</code> is within the circumscribing circle or not is equivalent to checking whether <code>q</code> is above or below the said supporting plane.</p>
<h2><a class="anchor" id="Section_2D_ToS_Imprecision"></a>
Representation of a Point on the Sphere</h2>
<p>The theoretical definition of Delaunay triangulations in the previous section assumes that points in \( \mathcal{P}\) lie exactly on the sphere. In a real world however, one usually does not manipulate points that lie exactly on \( \mathbb{S}\) because the chosen number type is not able to represent square roots exactly, such as \( \mathtt{float}\), or \( \mathtt{double}\). Some specific number types are able to represent exactly all points on the sphere, for example the class <code><a class="elRef" href="../Number_types/class_c_o_r_e_1_1_expr.html">CORE::Expr</a></code>, but this comes with the drawback of a substantially higher computational cost.</p>
<p>This lack of exact representation is an obvious problem as the interpretation of the Delaunay property as an orientation test does not stand if points do not lie in a convex position.</p>
<p>This gap between the theoretical and the practical settings was addressed by Caroli et al. <a class="el" href="citelist.html#CITEREF_cgal:ccplr-redtp-10">[1]</a> : the solution is to use a <em>regular</em> triangulation, which is a generalization of the Delaunay triangulation to sets of <em>weighted points</em> (see <a class="elRef" href="../Triangulation_2/index.html#Section_2D_Triangulations_Regular">2D Regular Triangulations</a> for more information). A weighted point \((p,w)\) of \( \mathbb{R}^2\) can naturally be seen as as a circle with center \( p\) and radius \( r\) such that \( r^2 = w\) and similarly to Delaunay triangulations and the definition of regular triangulations in \( \mathbb{R}^2\) can be naturally extended to circles on \( \mathbb{S}\). Given a set of points \( \mathcal{P}_3\) living in \( \mathbb{R}^3\), Caroli et al. compute a regular triangulation of the set of weighted points \( \mathcal{P}_w\) where the weighted points of \( \mathcal{P}_w\) are the projection of the points of \( \mathcal{P}_3\) onto \( \mathbb{S}\), and whose weights are based on the projection distance. Furthermore, they show that if the Euclidean distance between the points of \( \mathcal{P}_w\) is sufficiently large, and if the points are sufficiently close to the sphere, then the Delaunay triangulation of the Delaunay triangulation of \( \mathcal{P}_3\) is exactly the regular triangulation of \( \mathcal{P}_w\). As a consequence is that one can manipulate 3D points that are not exactly on the sphere, and it possible to build the Delaunay triangulation without taking the weights into account, as long as the points are sufficiently far from each other.</p>
<p>Caroli et al. et provide bounds on this separation criterion for the case of the \( \mathtt{double}\) number type: two points must be at least \( 2^{-25}r\) apart. This is a condition that is generally satisfied for most inputs: if \( r\) were for example the radius of the Earth, roughly 6300 kms, then the point separation requirement would be of the order of 1 meter.</p>
<h1><a class="anchor" id="Section_2D_ToS_Implementation"></a>
Implementation</h1>
<p>The main class of this package is the class <code><a class="el" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html" title="The class Delaunay_triangulation_on_sphere_2 is designed to represent the Delaunay triangulation of a...">CGAL::Delaunay_triangulation_on_sphere_2</a></code>; it represents a Delaunay triangulation on the sphere, and provides insertion and removal of vertices, as well as tools to draw the triangulation and its dual, the Voronoi diagram. The base of <code><a class="el" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html" title="The class Delaunay_triangulation_on_sphere_2 is designed to represent the Delaunay triangulation of a...">CGAL::Delaunay_triangulation_on_sphere_2</a></code> is the class <code><a class="el" href="class_c_g_a_l_1_1_triangulation__on__sphere__2.html" title="The class Triangulation_on_sphere_2 is the basic class designed to represent a triangulation of a poi...">CGAL::Triangulation_on_sphere_2</a></code>. It represents a triangulation on the sphere, but does <em>not</em> support insertion or removal of vertices. Both classes are built on top of a data structure called the triangulation data structure. The triangulation data structure can be thought of as a container for the faces and vertices of the triangulation. This data structure also takes care of all the combinatorial aspects of the triangulation.</p>
<p>These triangulation classes are intentionally very similar to <code><a class="elRef" href="../Triangulation_2/class_c_g_a_l_1_1_delaunay__triangulation__2.html">CGAL::Delaunay_triangulation_2</a></code> and <code><a class="elRef" href="../Triangulation_2/class_c_g_a_l_1_1_triangulation__2.html">CGAL::Triangulation_2</a></code> as both classes represent triangulations of a 2-manifold domain without boundary. As such, many details about the implementation are not repeated here, and complementary information can be found in the Sections <a class="elRef" href="../Triangulation_2/index.html#Section_2D_Triangulations_Representation">Representation</a>, <a class="elRef" href="../Triangulation_2/index.html#Section_2D_Triangulations_Software_Design">Software Design</a>, and <a class="elRef" href="../Triangulation_2/index.html#Section_2D_Triangulations_Basic">Basic Triangulations</a> of the package <a class="elRef" href="../Manual/packages.html#PkgTriangulation2">2D Triangulations</a>.</p>
<p>However, a significant departure from Euclidean 2D triangulations is the following: since the triangulation data structure represents a 2-manifold without boundary, it is necessary for 2D triangulations to introduce so-called <em>infinite faces</em> to complete the "real" triangulation (see <a class="elRef" href="../Triangulation_2/index.html#Triangulation_2TheSetofFaces">The Set of Faces</a>). On the sphere, this trick is not necessary as the triangulation itself is already a 2-manifold without boundary.</p>
<h2><a class="anchor" id="Section_2D_ToS_Ghost"></a>
Ghost Faces</h2>
<p>There is an exception to the previous statement: in degenerate configurations where all points lie on the same hemisphere, the Delaunay triangulation on the sphere theoretically has a border. Internally however, the triangulation data structure must remain a 2-manifold at all time. To ensure this property, fictitious faces referred to as <em>ghost faces</em> are added. These faces are characterized by the fact that the center of the sphere does not (strictly) lie on the positive side of the supporting plane of the face. Conversely, faces that are not ghost faces are called <em>solid faces</em>, and edges of such faces are <em>solid edges</em>.</p>
<p><a class="anchor" id="fig__fig_TOS2_ghost"></a></p><center> <img src="ghost_faces.png" alt="" style="max-width:70%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__fig_TOS2_ghost">Figure 42.3</a> Solid (blue) and ghost (orange) faces of a Delaunay triangulation on the sphere. View from above (leftmost), and below (middle and rightmost). </p> </div> <p> <br>
</p>
<h2><a class="anchor" id="Section_2D_ToS_Traits"></a>
Traits Classes and Choice of Kernel</h2>
<p>Two traits classes are offered with this package as models of the concept <code><a class="el" href="class_delaunay_triangulation_on_sphere_traits__2.html">DelaunayTriangulationOnSphereTraits_2</a></code>: </p><ul>
<li>
<code><a class="el" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__traits__2.html" title="The class Delaunay_triangulation_on_sphere_traits_2 is a model of the concept DelaunayTriangulationOn...">CGAL::Delaunay_triangulation_on_sphere_traits_2</a></code>: This is the simplest possible traits, which represents points on sphere directly as 3D points. If its kernel template parameter cannot represent all points on the sphere exactly, it employs the solution described in Section <a class="el" href="index.html#Section_2D_ToS_Imprecision">Representation of a Point on the Sphere</a> to determine whether a point should be considered on the sphere, or too close to an existing vertex.  </li>
<li>
<code><a class="el" href="class_c_g_a_l_1_1_projection__on__sphere__traits__3.html" title="The class Projection_on_sphere_traits_3 is a model of the concept DelaunayTriangulationOnSphereTraits...">CGAL::Projection_on_sphere_traits_3</a></code>: This traits class utilizes a custom internal point type for points on the sphere: given a point <code>p</code> in 3D space, this traits class manipulates directly its projection on the sphere (that is, the intersection of the sphere and the segment with endpoints <code>p</code> and the center of the sphere). Consequently, all points to be inserted are on the sphere. This traits class enables manipulating points that are not on the sphere, but whose triangulation on the sphere is still interesting, such as geographical coordinates with altitude.  </li>
</ul>
<p>Both these classes are templated by a kernel. The choice of this kernel is important to ensure a correct result: for the construction of triangulations to be safe, the kernel should provide exact predicates (for example, <code><a class="elRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></code>). In addition, some auxiliary functions such as those used in the construction of the Voronoi diagram require creating new geometric points; as such, a kernel offering an exact representation of points on the sphere and exact constructions (for example, <code><a class="elRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__exact__constructions__kernel__with__sqrt.html">CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt</a></code>) should be used if one wants to avoid otherwise inevitable numerical approximations.</p>
<h2><a class="anchor" id="Section_2D_ToS_Lowdim"></a>
Dimension of a Triangulation on the Sphere</h2>
<p>Mostly by convention with other triangulations, the dimension of a triangulation on the sphere is defined as follows: </p><ul>
<li>
<code>-2</code>, if the triangulation is empty; </li>
<li>
<code>-1</code>, if the triangulation contains a single vertex; </li>
<li>
<code>0</code>, if the triangulation contains exactly two vertices; </li>
<li>
<code>1</code>, if the triangulation contains at least three coplanar vertices (which do not necessarily lie on a great circle); </li>
<li>
<code>2</code>, if the triangulation contains at least four non-coplanar vertices. </li>
</ul>
<p>Note that a triangulation of dimension <code>1</code> is just a polygon drawn on a circle. The polygon is not triangulated itself. Thus the triangulation of dimension <code>1</code> consists of a planar polygon and has no faces.</p>
<h2><a class="anchor" id="Section_2D_ToS_Embedding"></a>
Geometric Embeddings</h2>
<p>The descriptions of Delaunay (and regular) triangulations over \( \mathbb{S}\) have so far been mostly combinatorial. The question of the geometrical embedding of the simplices of the triangulation is also interesting. The two natural embedding of edges and faces of a triangulation of a set of points on \( \mathbb{S}\) are to use either <em>straight</em> simplex, that is using three-dimensional segments and triangles for the edges and faces of the triangulation, or to use a <em>curved</em> embedding, where the edges are arc segments of great circles over \( \mathbb{S}\). In the latter choice, the geometrical embedding of the face is defined implicitly by its three edges.</p>
<p>Both choices are available to users, for example using either <code><a class="el" href="class_c_g_a_l_1_1_triangulation__on__sphere__2.html#a67bf1c3b2d51885487819d59622b4ef2" title="returns the 3D line segment formed by the vertices of the edge e.">Triangulation_on_sphere_2::segment()</a></code> or <code><a class="el" href="class_c_g_a_l_1_1_triangulation__on__sphere__2.html#af54cb7ecf4defe0760c0e87e7acf317a" title="returns the great circle arc formed by the vertices of the edge e.">Triangulation_on_sphere_2::segment_on_sphere()</a></code>. Similar choices are available in the construction of the dual, the Voronoi diagram.</p>
<p><a class="anchor" id="fig__fig_TOS2_embedding"></a></p><center> <img src="geometric_embedding.png" alt="" style="max-width:70%;" class="inline"> </center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__fig_TOS2_embedding">Figure 42.4</a> Curved (left) and straight (right) geometric embeddings of the edges of the Delaunay triangulation of the French (including overseas territories) post offices. </p> </div> <p> <br>
</p>
<h1><a class="anchor" id="Section_2D_ToS_Examples"></a>
Examples</h1>
<h2><a class="anchor" id="Section_2D_ToS_Ex_Basic"></a>
Basic Example</h2>
<p>The following example uses the simplest traits class provided in this package. It demonstrates how to iteratively insert a few points, and how the dimension and the data structure of the triangulation evolve with these insertions.</p>
<p><br>
<b>File</b> <a class="el" href="_triangulation_on_sphere_2_2triang_on_sphere_8cpp-example.html">Triangulation_on_sphere_2/triang_on_sphere.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_on_sphere_traits_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_on_sphere_2.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__traits__2.html">CGAL::Delaunay_triangulation_on_sphere_traits_2&lt;K&gt;</a>  Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html">CGAL::Delaunay_triangulation_on_sphere_2&lt;Traits&gt;</a>    DToS2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Traits::Point_3                                     Point_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  points.emplace_back( 2, 1, 1);</div>
<div class="line">  points.emplace_back(-2, 1, 1); <span class="comment">// not on the sphere</span></div>
<div class="line">  points.emplace_back( 0, 1, 1);</div>
<div class="line">  points.emplace_back( 1, 2, 1);</div>
<div class="line">  points.emplace_back( 0, 1, 1); <span class="comment">// duplicate of #3</span></div>
<div class="line">  points.emplace_back( 1, 0, 1);</div>
<div class="line">  points.emplace_back( 1, 1, 2);</div>
<div class="line"> </div>
<div class="line">  Traits traits(Point_3(1, 1, 1), 1); <span class="comment">// sphere center on (1,1,1), with radius 1</span></div>
<div class="line">  DToS2 dtos(traits);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> Point_3&amp; pt : points)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"Inserting ("</span> &lt;&lt; pt</div>
<div class="line">              &lt;&lt; <span class="stringliteral">") at squared distance "</span> &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(pt, traits.center())</div>
<div class="line">              &lt;&lt; <span class="stringliteral">" from the center of the sphere; is it on there sphere? "</span></div>
<div class="line">              &lt;&lt; (traits.is_on_sphere(pt) ? <span class="stringliteral">"yes"</span> : <span class="stringliteral">"no"</span>) &lt;&lt; std::endl;</div>
<div class="line">    dtos.insert(pt);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"After insertion, the dimension of the triangulation is: "</span> &lt;&lt; dtos.dimension() &lt;&lt; <span class="stringliteral">"\n"</span>;</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"It has:\n"</span>;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices\n"</span>;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_edges() &lt;&lt; <span class="stringliteral">" edges\n"</span>;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_solid_faces() &lt;&lt; <span class="stringliteral">" solid faces\n"</span>;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_ghost_faces() &lt;&lt; <span class="stringliteral">" ghost faces\n"</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_io_funcs_o_f_f.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, dtos, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2_html"><div class="ttname"><a href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html">CGAL::Delaunay_triangulation_on_sphere_2</a></div><div class="ttdoc">The class Delaunay_triangulation_on_sphere_2 is designed to represent the Delaunay triangulation of a...</div><div class="ttdef"><b>Definition:</b> Delaunay_triangulation_on_sphere_2.h:32</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_delaunay__triangulation__on__sphere__traits__2_html"><div class="ttname"><a href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__traits__2.html">CGAL::Delaunay_triangulation_on_sphere_traits_2</a></div><div class="ttdoc">The class Delaunay_triangulation_on_sphere_traits_2 is a model of the concept DelaunayTriangulationOn...</div><div class="ttdef"><b>Definition:</b> Delaunay_triangulation_on_sphere_traits_2.h:38</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel_html"><div class="ttname"><a href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a></div></div>
<div class="ttc" id="agroup___pkg_stream_support_io_funcs_o_f_f_html_ga9682021a1047600910151826eaa75a5b"><div class="ttname"><a href="../Stream_support/group___pkg_stream_support_io_funcs_o_f_f.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a></div><div class="ttdeci">bool write_OFF(std::ostream &amp;os, const PointRange &amp;points, const PolygonRange &amp;polygons, const NamedParameters &amp;np=parameters::default_values())</div></div>
<div class="ttc" id="agroup__squared__distance__grp_html_ga1ff73525660a052564d33fbdd61a4f71"><div class="ttname"><a href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a></div><div class="ttdeci">Kernel::FT squared_distance(Type1&lt; Kernel &gt; obj1, Type2&lt; Kernel &gt; obj2)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="Section_2D_ToS_Ex_Exact"></a>
Using an Exact Kernel</h2>
<p>The following example illustrates the limitation of using a kernel with inexact representation of points on the sphere and the rejection of a point for being too close to an already existing vertex. A kernel providing exact representation is also shown to be able to insert these two extremely close points.</p>
<p><br>
<b>File</b> <a class="el" href="_triangulation_on_sphere_2_2triang_on_sphere_exact_8cpp-example.html">Triangulation_on_sphere_2/triang_on_sphere_exact.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_exact_constructions_kernel_with_sqrt.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_on_sphere_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_on_sphere_traits_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Kernel&gt;</div>
<div class="line"><span class="keywordtype">void</span> create_triangulation(<span class="keyword">const</span> std::string&amp; filename)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Kernel::FT                                          FT;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_projection__on__sphere__traits__3.html">CGAL::Projection_on_sphere_traits_3&lt;Kernel&gt;</a>                  Traits;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html">CGAL::Delaunay_triangulation_on_sphere_2&lt;Traits&gt;</a>             DToS2;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Traits::Point_3                                     Point_3;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"\n-- Constructing triangulation with Kernel: "</span> &lt;&lt; <span class="keyword">typeid</span>(<a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a>).name() &lt;&lt; <span class="stringliteral">" --"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  <span class="keywordtype">double</span> x, y, z;</div>
<div class="line"> </div>
<div class="line">  std::ifstream in(filename);</div>
<div class="line">  <span class="keywordflow">if</span>(!in)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file: "</span> &lt;&lt; filename &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(in &gt;&gt; x &gt;&gt; y &gt;&gt; z)</div>
<div class="line">    points.emplace_back(x, y, z);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add an extra point that would be too close to 'p' with a basic kernel such as CGAL::EPICK,</span></div>
<div class="line">  <span class="keyword">const</span> Point_3&amp; p = points.back();</div>
<div class="line">  <span class="keyword">const</span> FT tiny = 100 * std::numeric_limits&lt;double&gt;::epsilon();</div>
<div class="line">  points.emplace_back(p.x() + tiny, p.y() - tiny, p.z() + tiny);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Adding point  "</span> &lt;&lt; points.back() &lt;&lt; <span class="stringliteral">"\nvery close to "</span> &lt;&lt; p &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Squared distance between points "</span> &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(points.back(), p) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points in input"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Traits traits(Point_3(0, 0, 0), 100); <span class="comment">// centered on (0,0,0), with radius 100</span></div>
<div class="line">  DToS2 dtos(points.begin(), points.end(), traits);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; dtos.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; dtos.number_of_faces() &lt;&lt; <span class="stringliteral">" faces"</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  std::cout.precision(17);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This kernel CAN represent exactly all points of the sphere</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__exact__constructions__kernel__with__sqrt.html">CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt</a>  EPECK_w_SQRT;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This kernel CANNOT represent exactly all points of the sphere</span></div>
<div class="line">  <span class="comment">// and thus a separation mechanism is needed to ensure that no points are hidden</span></div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>          EPICK;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/poste_france.xyz"</span>);</div>
<div class="line"> </div>
<div class="line">  create_triangulation&lt;EPICK&gt;(filename);</div>
<div class="line">  create_triangulation&lt;EPECK_w_SQRT&gt;(filename);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_exact__predicates__exact__constructions__kernel__with__sqrt_html"><div class="ttname"><a href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__exact__constructions__kernel__with__sqrt.html">CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt</a></div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_projection__on__sphere__traits__3_html"><div class="ttname"><a href="class_c_g_a_l_1_1_projection__on__sphere__traits__3.html">CGAL::Projection_on_sphere_traits_3</a></div><div class="ttdoc">The class Projection_on_sphere_traits_3 is a model of the concept DelaunayTriangulationOnSphereTraits...</div><div class="ttdef"><b>Definition:</b> Projection_on_sphere_traits_3.h:23</div></div>
<div class="ttc" id="anamespace_kernel_html"><div class="ttname"><a href="../Kernel_23/namespace_kernel.html">Kernel</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="Section_2D_ToS_Ex_Project"></a>
Using the Projection Traits Class</h2>
<p>In this example, the use of the projection traits class is illustrated.</p>
<p><br>
<b>File</b> <a class="el" href="_triangulation_on_sphere_2_2triang_on_sphere_proj_8cpp-example.html">Triangulation_on_sphere_2/triang_on_sphere_proj.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_on_sphere_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_on_sphere_traits_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a>          K;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_projection__on__sphere__traits__3.html">CGAL::Projection_on_sphere_traits_3&lt;K&gt;</a>                       Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html">CGAL::Delaunay_triangulation_on_sphere_2&lt;Traits&gt;</a>             DToS2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> Traits::Point_3                                              Point_3;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;Point_3&gt; points;</div>
<div class="line">  points.emplace_back( 3,  1,  1);</div>
<div class="line">  points.emplace_back(-8,  1,  1);</div>
<div class="line">  points.emplace_back( 1,  2,  1);</div>
<div class="line">  points.emplace_back( 1, -2,  1);</div>
<div class="line">  points.emplace_back( 1,  1, 10);</div>
<div class="line"> </div>
<div class="line">  Traits traits(Point_3(1,1,1)); <span class="comment">// radius is 1 by default</span></div>
<div class="line">  DToS2 dtos(traits);</div>
<div class="line"> </div>
<div class="line">  Traits::Construct_point_on_sphere_2 cst = traits.construct_point_on_sphere_2_object();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pt : points)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"----- Inserting ("</span> &lt;&lt; pt</div>
<div class="line">              &lt;&lt; <span class="stringliteral">") at squared distance "</span> &lt;&lt; <a class="code hl_functionRef" href="../Kernel_23/group__squared__distance__grp.html#ga1ff73525660a052564d33fbdd61a4f71">CGAL::squared_distance</a>(pt, traits.center())</div>
<div class="line">              &lt;&lt; <span class="stringliteral">" from the center of the sphere"</span> &lt;&lt; std::endl;</div>
<div class="line">    dtos.insert(cst(pt));</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"The triangulation now has dimension: "</span> &lt;&lt; dtos.dimension() &lt;&lt; <span class="stringliteral">" and\n"</span>;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_edges() &lt;&lt; <span class="stringliteral">" edges"</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_solid_faces() &lt;&lt; <span class="stringliteral">" solid faces"</span> &lt;&lt; std::endl;</div>
<div class="line">    std::cout &lt;&lt; dtos.number_of_ghost_faces() &lt;&lt; <span class="stringliteral">" ghost faces"</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_io_funcs_o_f_f.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, dtos, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Section_2D_ToS_Ex_Range"></a>
Insertion of a Range and Spatial Sorting</h2>
<p>The following example demonstrates how to insert a range of points at once. This enables an internal algorithm to sort the set of points to ensure locality when inserting points, which greatly speeds up the insertion.</p>
<p><br>
<b>File</b> <a class="el" href="_triangulation_on_sphere_2_2triang_on_sphere_range_8cpp-example.html">Triangulation_on_sphere_2/triang_on_sphere_range.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_predicates_inexact_constructions_kernel.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Delaunay_triangulation_on_sphere_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Projection_on_sphere_traits_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_classRef" href="../Kernel_23/class_c_g_a_l_1_1_exact__predicates__inexact__constructions__kernel.html">CGAL::Exact_predicates_inexact_constructions_kernel</a> K;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_projection__on__sphere__traits__3.html">CGAL::Projection_on_sphere_traits_3&lt;K&gt;</a>              Traits;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_delaunay__triangulation__on__sphere__2.html">CGAL::Delaunay_triangulation_on_sphere_2&lt;Traits&gt;</a>    DToS2;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> DToS2::Point_3                                      Point;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line">{</div>
<div class="line">  std::cout.precision(17);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> std::string filename = (argc &gt; 1) ? argv[1] : CGAL::data_file_path(<span class="stringliteral">"points_3/radar.xyz"</span>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;Point&gt; points;</div>
<div class="line">  <span class="keywordtype">double</span> x, y, z;</div>
<div class="line"> </div>
<div class="line">  std::ifstream in(filename);</div>
<div class="line">  <span class="keywordflow">if</span>(!in)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Invalid input file: "</span> &lt;&lt; filename &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span>(in &gt;&gt; x &gt;&gt; y &gt;&gt; z)</div>
<div class="line">    points.emplace_back(x, y, z);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; points.size() &lt;&lt; <span class="stringliteral">" points in input"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Traits traits(Point(0, 0, 0), 100);</div>
<div class="line">  DToS2 dtos(points.begin(), points.end(), traits);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; dtos.number_of_vertices() &lt;&lt; <span class="stringliteral">" vertices"</span> &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; dtos.number_of_solid_faces() &lt;&lt; <span class="stringliteral">" solid faces"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_io_funcs_o_f_f.html#ga9682021a1047600910151826eaa75a5b">CGAL::IO::write_OFF</a>(<span class="stringliteral">"result.off"</span>, dtos, CGAL::parameters::stream_precision(17));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="Section_2D_ToS_Design"></a>
Design and Implementation History</h1>
<p>Prototype code implementing the publication of Caroli et al. <a class="el" href="citelist.html#CITEREF_cgal:ccplr-redtp-10">[1]</a> was developed over the two internships of Oliver Rouiller and Claudia Werner at Inria, under the supervision of Monique Teillaud and with the help of Sébastien Loriot. Based on this prototype, Mael Rouxel-Labbé developed the initial version of this package.</p>
<p>The work was partially supported by the grant ANR-17-CE40-0033 of the French National Research Agency ANR <a href="https://members.loria.fr/Monique.Teillaud/collab/SoS/">(project SoS)</a> and INTER/ANR/16/11554412/SoS of the Luxembourg National Research fund FNR. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
