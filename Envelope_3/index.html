<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Envelope_3/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - 3D Envelopes: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - 3D Envelopes
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Envelopes_of_Surfaces_in_3D"></a> <a class="anchor" id="chapterEnvelope3"></a> </p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Authors</dt><dd>Dan Halperin, Michal Meyerovitch, Ron Wein, and Baruch Zukerman</dd></dl>
<h1><a class="anchor" id="Envelope_3Introduction"></a>
Introduction</h1>
<p>A continuous surface \( S\) in \( {\mathbb R}^3\) is called <em> \( xy\)-monotone</em>, if every line parallel to the \( z\)-axis intersects it at a single point at most. For example, the sphere \( x^2 + y^2 + z^2 = 1\) is <em>not</em> \( xy\)-monotone as the \( z\)-axis intersects it at \( (0, 0, -1)\) and at \( (0, 0, 1)\); however, if we use the \( xy\)-plane to split it to an upper hemisphere and a lower hemisphere, these two hemispheres are \( xy\)-monotone.</p>
<p>An \( xy\)-monotone surface can therefore be represented as a bivariate function \( z = S(x,y)\), defined over some continuous range \( R_S \subseteq {\mathbb R}^2\). Given a set \( {\cal S} = \{ S_1, S_2, \ldots, S_n \}\) of \( xy\)-monotone surfaces, their <em>lower envelope</em> is defined as the point-wise minimum of all surfaces. Namely, the lower envelope of the set \( {\cal S}\) can be defined as the following function:  </p><p class="formulaDsp">
\begin{eqnarray*}
{\cal L}_{{\cal S}} (x,y) = \min_{1 \leq k \leq n}{\overline{S}_k (x,y)} \ ,
\end{eqnarray*}
</p>
<p> where we define \(\overline{S}_k(x,y) = S_k(x,y)\) for \((x,y) \in R_{S_k}\), and \(\overline{S}_k(x,y) = \infty\) otherwise.</p>
<p>Similarly, the <em>upper envelope</em> of \({\cal S}\) is the point-wise maximum of the \(xy\)-monotone surfaces in the set:  </p><p class="formulaDsp">
\begin{eqnarray*}
{\cal U}_{{\cal S}} (x,y) = \max_{1 \leq k \leq n}{\underline{S}_k (x,y)} \ ,
\end{eqnarray*}
</p>
<p> where in this case \( \underline{S}_k(x,y) = -\infty\) for \( (x,y) \not\in
R_{S_k}\).</p>
<p>Given a set of \( xy\)-monotone surfaces \( {\cal S}\), the <em>minimization diagram</em> of \( {\cal S}\) is a subdivision of the \( xy\)-plane into cells, such that the identity of the surfaces that induce the lower diagram over a specific cell of the subdivision (be it a face, an edge, or a vertex) is the same. In non-degenerate situation, a face is induced by a single surface (or by no surfaces at all, if there are no \( xy\)-monotone surfaces defined over it), an edge is induced by a single surface and corresponds to its projected boundary, or by two surfaces and corresponds to their projected intersection curve, and a vertex is induced by a single surface and corresponds to its projected boundary point, or by three surfaces and corresponds to their projected intersection point. The <em>maximization diagram</em> is symmetrically defined for upper envelopes. In the rest of this chapter, we refer to both these diagrams as <em>envelope diagrams</em>.</p>
<p>It is easy to see that an envelope diagram is no more than a planar arrangement (see Chapter <a class="elRef" href="../Arrangement_on_surface_2/index.html#chapterArrangement_on_surface_2">2D Arrangements</a>), represented using an extended DCEL structure, such that every DCEL record (namely each face, halfedge and vertex) stores an additional container of it originators: the \( xy\)-monotone surfaces that induce this feature.</p>
<p>Lower and upper envelopes can be efficiently computed using a divide-and-conquer approach. First note that the envelope diagram for a single \( xy\)-monotone curve \( S_k\) is trivial to compute: we project the boundary of its range of definition \( R_{S_k}\) onto the \( xy\)-plane, and label the faces it induces accordingly. Given a set \( {\cal D}\) of (non necessarily \( xy\)-monotone) surfaces in \( {\mathbb R}^3\), we subdivide each surface into a finite number of weakly \( xy\)-monotone surfaces, <span class="footnote">We consider <em>vertical</em> surfaces, namely patches of planes that are perpendicular to the \( xy\)-plane, as <em>weakly</em> \( xy\)-monotone, to handle degenerate inputs properly.</span> and obtain the set \( {\cal S}\). Then, we split the set into two disjoint subsets \( {\cal S}_1\) and \( {\cal S}_2\), and we compute their envelope diagrams recursively. Finally, we merge the diagrams, and we do this by overlaying them and then applying some post-processing on the resulting diagram. The post-processing stage is non-trivial and involves the projection of intersection curves onto the \( xy\)-plane - see <a class="el" href="citelist.html#CITEREF_cgal:m-rgece-06">[1]</a> for more details.</p>
<h1><a class="anchor" id="Envelope_3The"></a>
The Envelope-Traits Concept</h1>
<p>The implementation of the envelope-computation algorithm is generic and can handle arbitrary surfaces. It is parameterized with a traits class, which defines the geometry of surfaces it handles, and supports all the necessary functionality on these surfaces, and on their projections onto the \( xy\)-plane. The traits class must model the <code><a class="el" href="class_envelope_traits__3.html" title="This concept defines the minimal set of geometric predicates and operations needed to compute the env...">EnvelopeTraits_3</a></code> concept, the details of which are given below.</p>
<p>As the representation of envelope diagrams is based on 2D arrangements, and the envelop-computation algorithm employs overlay of planar arrangements, the <code><a class="el" href="class_envelope_traits__3.html" title="This concept defines the minimal set of geometric predicates and operations needed to compute the env...">EnvelopeTraits_3</a></code> refines the <code><a class="elRef" href="../Arrangement_on_surface_2/class_arrangement_x_monotone_traits__2.html">ArrangementXMonotoneTraits_2</a></code> concept. Namely, a model of this concept must define the planar types <code><a class="elRef" href="../Kernel_23/class_c_g_a_l_1_1_point__2.html">Point_2</a></code> and <code>X_monotone_curve_2</code> and support basic operations on them, as listed in Section <a class="elRef" href="../Arrangement_on_surface_2/index.html#aos_sec-geom_traits">The Geometry Traits</a>. Moreover, it must define the spatial types <code>Surface_3</code> and <code>Xy_monotone_surface_3</code> (in practice, these two types may be the same). Any model of the envelope-traits concept must also support the following operations on these spatial types:</p>
<p><a class="anchor" id="fig__env3_figcomp_over"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="compare_over_point.png" alt="">
</div>
   </td><td><div class="image">
<img src="compare_over_curve.png" alt="">
</div>
    </td></tr>
<tr align="center">
<td>(a)</td><td>(b) </td></tr>
</table>
</center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__env3_figcomp_over">Figure 39.1</a> (a) The spheres \( S_1\) and \( S_2\) have only one two-dimensional point \( p\) in their common \( xy\)-definition range. They do not necessarily intersect over this point, and the envelope-construction algorithm needs to determine their relative \(
z\)-order over \( p\). (b) The \( z\)-order of the surfaces \(
S_1\) and \( S_2\) should be determined over the \( x\)-monotone curve \( c\). The comparison is performed over the <em>interior</em> of \( c\), excluding its endpoints. </p> </div> <p> <br>
</p>
<ul>
<li>
Subdivide a given surface into continuous \( xy\)-monotone surfaces. It is possible to disregard \( xy\)-monotone surfaces that do not contribute to the surface envelope at this stage (for example, if we are given a sphere, it is possible to return just its lower hemisphere if we are interested in the lower envelope; the upper hemisphere is obviously redundant). </li>
<li>
<p class="startli">Given an \( xy\)-monotone surface \( S\), construct all planar curves that form the boundary of the vertical projection \( S\)'s boundary onto the \( xy\)-plane.</p>
<p class="endli">This operation is used at the bottom of the recursion to build the minimization diagram of a single \( xy\)-monotone surface. </p>
</li>
<li>
Construct all geometric entities that comprise the projection (onto the \( xy\)-plane) of the intersection between two \( xy\)-monotone surfaces \( S_1\) and \( S_2\). These entities may be: <ul>
<li>
A planar curve, which is the projection of an 3D intersection curve of \( S_1\) and \( S_2\) (for example, the intersection curve between two spheres is a 3D circle, which becomes an ellipse when projected onto the \( xy\)-plane). In many cases it is also possible to indicate the multiplicity of the intersection: if it is odd, the two surfaces intersect transversely and change their relative \( z\)-positions on either side of the intersection curve; if it the multiplicity is even, they maintain their relative \( z\)-position. Providing the multiplicity information is optional. When provided, it is used by the algorithm to determine the relative order of \( S_1\) and \( S_2\) on one side of their intersection curve when their order on the other side of that curve is known, thus improving the performance of the algorithm. </li>
<li>
A point, induces by the projection of a tangency point of \( S_1\) and \( S_2\), <em>or</em> by the projection of a vertical intersection curve onto the \( xy\)-plane. </li>
</ul>
Needless to say, the set of intersection entities may be empty in case \( S_1\) and \( S_2\) do not intersect. </li>
<li>
Given two \( xy\)-monotone surfaces \( S_1\) and \( S_2\), and a planar point \( p = (x_0,y_0)\) that lies in their common \( xy\)-definition range, determine the \( z\)-order of \( S_1\) and \( S_2\) over \( p\), namely compare \( S_1(x_0,y_0)\) and \( S_2(x_0,y_0)\). This operation is used only in degenerate situations, in order to determine the surface inducing the envelope over a vertex (see <a class="el" href="index.html#fig__env3_figcomp_over">Figure 39.1</a> (a) for an illustration of a situation when this operation is used). </li>
<li>
<p class="startli">Given two \( xy\)-monotone surfaces \( S_1\) and \( S_2\), and a planar \( x\)-monotone curve \( c\), which is a part of their projected intersection, determine the \( z\)-order of \( S_1\) and \( S_2\) immediately above (or, similarly, immediately below) the curve \( c\). Note that \( c\) is a planar \( x\)-monotone curve, and we refer to the region above (or below) it in the <em>plane</em>. If \( c\) is a vertical curve, we regard the region to its left as lying above it, and the region to its right as lying below it.</p>
<p class="endli">This operation is used by the algorithm to determine the surface that induce the envelope over a face incident to \( c\). </p>
</li>
<li>
<p class="startli">Given two \( xy\)-monotone surfaces \( S_1\) and \( S_2\), and a planar \( x\)-monotone curve \( c\), which fully lies in their common \( xy\)-definition range, and such that \( S_1\) and \( S_2\) do not intersect over the interior of \( c\), determine the relative \( z\)-order of \( s_1\) and \( s_2\) over the interior of \( c\). Namely, we compare \( S_1(x_0,y_0)\) and \( S_2(x_0,y_0)\) for some point \( (x_0, y_0)\) on \( c\).</p>
<p class="endli">This operation is used by the algorithm to determine which surface induce the envelope over an edge associated with the \( x\)-monotone curve \( c\), or of a face incident to \( c\), in situations where the previous predicate cannot be used, as \( c\) is <em>not</em> an intersection curve of \( S_1\) and \( S_2\) (see <a class="el" href="index.html#fig__env3_figcomp_over">Figure 39.1</a> (b) for an illustration of a situation where this operation is used). </p>
</li>
</ul>
<p>The package currently contains a traits class for named <code><a class="el" href="class_c_g_a_l_1_1_env__triangle__traits__3.html" title="The traits class template Env_triangle_traits_3 models the EnvelopeTraits_3 concept,...">Env_triangle_traits_3</a>&lt;<a class="elRef" href="../Kernel_23/class_kernel.html">Kernel</a>&gt;</code> handling 3D triangles, and another named <code><a class="el" href="class_c_g_a_l_1_1_env__sphere__traits__3.html" title="The traits class Env_sphere_traits_3 models the EnvelopeTraits_3 concept, and is used for the constru...">Env_sphere_traits_3</a>&lt;ConicTraits&gt;</code> for 3D spheres, based on geometric operations on conic curves (ellipses). In addition, the package includes a traits-class decorator that enables users to attach external (non-geometric) data to surfaces. The usage of the various traits classes is demonstrated in the next section.</p>
<h1><a class="anchor" id="Envelope_3Examples"></a>
Examples</h1>
<h2><a class="anchor" id="Envelope_3ExampleforEnvelopeofTriangles"></a>
Example for Envelope of Triangles</h2>
<p><a class="anchor" id="fig__env3_figex_tri"></a></p><center> <table border="0">
<tr>
<td><div class="image">
<img src="ex_triangles.png" alt="">
</div>
   </td><td><div class="image">
<img src="ex_tri_le.png" alt="">
</div>
   </td><td><div class="image">
<img src="ex_tri_ue.png" alt="">
</div>
   </td></tr>
<tr align="center">
<td>(a)</td><td>(b)</td><td>(c) </td></tr>
</table>
</center>  <div class="cgal_figure_caption"> <p> <a class="el" href="index.html#fig__env3_figex_tri">Figure 39.2</a> (a) Two triangles in \( {\mathbb R}^3\), as given in <code>envelope_triangles.cpp</code>. (b) Their lower envelope. (c) Their upper envelope. </p> </div> <p> <br>
</p>
<p>The following example shows how to use the envelope-traits class for 3D triangles and how to traverse the envelope diagram. It constructs the lower and upper envelopes of the two triangles, as depicted in <a class="el" href="index.html#fig__env3_figex_tri">Figure 39.2</a> (a) and prints the triangles that induce each face and each edge in the output diagrams. For convenience, we use the traits-class decorator <code><a class="el" href="class_c_g_a_l_1_1_env__surface__data__traits__3.html" title="The class Env_surface_data_traits_3 is a model of the EnvelopeTraits_3 concept and serves as a decora...">Env_surface_data_traits_3</a></code> to label the triangles. When printing the diagrams, we just output the labels of the triangles:</p>
<p><br>
<b>File</b> <a class="el" href="_envelope_3_2envelope_triangles_8cpp-example.html">Envelope_3/envelope_triangles.cpp</a> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// Constructing the lower and the upper envelope of a set of triangles.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_rational.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Env_triangle_traits_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Env_surface_data_traits_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/envelope_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Number_type = CGAL::Exact_rational;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a> = <a class="code hl_structRef" href="../Kernel_23/struct_c_g_a_l_1_1_cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Traits_3 = <a class="code hl_class" href="class_c_g_a_l_1_1_env__triangle__traits__3.html">CGAL::Env_triangle_traits_3&lt;Kernel&gt;</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> = <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Kernel::Point_3</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_triangle__3.html">Triangle_3</a> = Traits_3::Surface_3;</div>
<div class="line"><span class="keyword">using </span>Data_traits_3 = <a class="code hl_class" href="class_c_g_a_l_1_1_env__surface__data__traits__3.html">CGAL::Env_surface_data_traits_3&lt;Traits_3, char&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Data_triangle_3 = Data_traits_3::Surface_3;</div>
<div class="line"><span class="keyword">using </span>Envelope_diagram_2 = <a class="code hl_class" href="class_c_g_a_l_1_1_envelope__diagram__2.html">CGAL::Envelope_diagram_2&lt;Data_traits_3&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Auxiliary function - print the features of the given envelope diagram. */</span></div>
<div class="line"><span class="keywordtype">void</span> print_diagram(<span class="keyword">const</span> Envelope_diagram_2&amp; diag) {</div>
<div class="line">  <span class="comment">// Go over all arrangement faces.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = diag.faces_begin(); fit != diag.faces_end(); ++fit) {</div>
<div class="line">    <span class="comment">// Print the face boundary.</span></div>
<div class="line">    <span class="keywordflow">if</span> (fit-&gt;is_unbounded()) std::cout &lt;&lt; <span class="stringliteral">"[Unbounded face]"</span>;</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Print the vertices along the outer boundary of the face.</span></div>
<div class="line">      <span class="keyword">auto</span> ccb = fit-&gt;outer_ccb();</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">"[Face]  "</span>;</div>
<div class="line">      <span class="keywordflow">do</span> std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; ccb-&gt;target()-&gt;point() &lt;&lt; <span class="stringliteral">")  "</span>;</div>
<div class="line">      <span class="keywordflow">while</span> (++ccb != fit-&gt;outer_ccb());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print the labels of the triangles that induce the envelope on this face.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"--&gt;  "</span> &lt;&lt; fit-&gt;number_of_surfaces() &lt;&lt; <span class="stringliteral">" triangles:"</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> sit = fit-&gt;surfaces_begin(); sit != fit-&gt;surfaces_end(); ++sit)</div>
<div class="line">      std::cout &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; sit-&gt;data();</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Go over all arrangement edges.</span></div>
<div class="line">  <a class="code hl_typedefRef" href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_arrangement__2.html#a50f87a7c4b684a0454efc754780aaef3">Envelope_diagram_2::Edge_const_iterator</a> eit;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> eit = diag.edges_begin(); eit != diag.edges_end(); ++eit) {</div>
<div class="line">    <span class="comment">// Print the labels of the triangles that induce the envelope on this edge.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"[Edge]  ("</span> &lt;&lt; eit-&gt;source()-&gt;point()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">") ("</span> &lt;&lt; eit-&gt;target()-&gt;point()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">") --&gt;  "</span> &lt;&lt; eit-&gt;number_of_surfaces()</div>
<div class="line">              &lt;&lt; <span class="stringliteral">" triangles:"</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> sit = eit-&gt;surfaces_begin(); sit != eit-&gt;surfaces_end(); ++sit)</div>
<div class="line">      std::cout &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; sit-&gt;data();</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The main program: */</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// Construct the input triangles, makred A and B.</span></div>
<div class="line">  std::list&lt;Data_triangle_3&gt; triangles;</div>
<div class="line">  <span class="keyword">auto</span> t1 = <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_triangle__3.html">Triangle_3</a>(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> (0, 0, 0), <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> (0, 6, 0), <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> (5, 3, 4));</div>
<div class="line">  triangles.push_back(Data_triangle_3(t1, <span class="charliteral">'A'</span>));</div>
<div class="line">  <span class="keyword">auto</span> t2 = <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_triangle__3.html">Triangle_3</a>(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> (6, 0, 0), <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> (6, 6, 0), <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_point__3.html">Point_3</a> (1, 3, 4));</div>
<div class="line">  triangles.push_back(Data_triangle_3(t2, <span class="charliteral">'B'</span>));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute and print the minimization diagram.</span></div>
<div class="line">  Envelope_diagram_2 min_diag;</div>
<div class="line">  <a class="code hl_function" href="group___pkg_envelope3_ref.html#gafd8dc9fadb187466e4c567099ec1a443">CGAL::lower_envelope_3</a>(triangles.begin(), triangles.end(), min_diag);</div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"The minimization diagram:"</span> &lt;&lt; std::endl;</div>
<div class="line">  print_diagram(min_diag);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute and print the maximization diagram.</span></div>
<div class="line">  Envelope_diagram_2 max_diag;</div>
<div class="line">  <a class="code hl_function" href="group___pkg_envelope3_ref.html#ga1fbbe89e27c3dc3404bbbb3b1f7ceea1">CGAL::upper_envelope_3</a> (triangles.begin(), triangles.end(), max_diag);</div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"The maximization diagram:"</span> &lt;&lt; std::endl;</div>
<div class="line">  print_diagram (max_diag);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_arrangement__2_html_a50f87a7c4b684a0454efc754780aaef3"><div class="ttname"><a href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_arrangement__2.html#a50f87a7c4b684a0454efc754780aaef3">CGAL::Arrangement_2&lt; EnvTraits &gt;::Edge_const_iterator</a></div><div class="ttdeci">Base::Edge_iterator Edge_const_iterator</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_env__surface__data__traits__3_html"><div class="ttname"><a href="class_c_g_a_l_1_1_env__surface__data__traits__3.html">CGAL::Env_surface_data_traits_3</a></div><div class="ttdoc">The class Env_surface_data_traits_3 is a model of the EnvelopeTraits_3 concept and serves as a decora...</div><div class="ttdef"><b>Definition:</b> Env_surface_data_traits_3.h:39</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_env__triangle__traits__3_html"><div class="ttname"><a href="class_c_g_a_l_1_1_env__triangle__traits__3.html">CGAL::Env_triangle_traits_3</a></div><div class="ttdoc">The traits class template Env_triangle_traits_3 models the EnvelopeTraits_3 concept,...</div><div class="ttdef"><b>Definition:</b> Env_triangle_traits_3.h:41</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_envelope__diagram__2_html"><div class="ttname"><a href="class_c_g_a_l_1_1_envelope__diagram__2.html">CGAL::Envelope_diagram_2</a></div><div class="ttdoc">The class-template Envelope_diagram_2 represents the minimization diagram that corresponds to the low...</div><div class="ttdef"><b>Definition:</b> envelope_3.h:26</div></div>
<div class="ttc" id="aclass_kernel_1_1_point__3_html"><div class="ttname"><a href="../Kernel_23/class_kernel_1_1_point__3.html">Kernel::Point_3</a></div></div>
<div class="ttc" id="aclass_kernel_1_1_triangle__3_html"><div class="ttname"><a href="../Kernel_23/class_kernel_1_1_triangle__3.html">Kernel::Triangle_3</a></div></div>
<div class="ttc" id="agroup___pkg_envelope3_ref_html_ga1fbbe89e27c3dc3404bbbb3b1f7ceea1"><div class="ttname"><a href="group___pkg_envelope3_ref.html#ga1fbbe89e27c3dc3404bbbb3b1f7ceea1">CGAL::upper_envelope_3</a></div><div class="ttdeci">void upper_envelope_3(InputIterator begin, InputIterator end, Envelope_diagram_2&lt; Traits &gt; &amp;diag)</div><div class="ttdoc">Computes the upper envelope of a set of surfaces in , as given by the range [begin,...</div></div>
<div class="ttc" id="agroup___pkg_envelope3_ref_html_gafd8dc9fadb187466e4c567099ec1a443"><div class="ttname"><a href="group___pkg_envelope3_ref.html#gafd8dc9fadb187466e4c567099ec1a443">CGAL::lower_envelope_3</a></div><div class="ttdeci">void lower_envelope_3(InputIterator begin, InputIterator end, Envelope_diagram_2&lt; Traits &gt; &amp;diag)</div><div class="ttdoc">Computes the lower envelope of a set of surfaces in , as given by the range [begin,...</div></div>
<div class="ttc" id="anamespace_kernel_html"><div class="ttname"><a href="../Kernel_23/namespace_kernel.html">Kernel</a></div></div>
<div class="ttc" id="astruct_c_g_a_l_1_1_cartesian_html"><div class="ttname"><a href="../Kernel_23/struct_c_g_a_l_1_1_cartesian.html">CGAL::Cartesian</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="Envelope_3ExampleforEnvelopeofSpheres"></a>
Example for Envelope of Spheres</h2>
<p>The next example demonstrates how to instantiate and use the envelope-traits class for spheres, based on the <code><a class="elRef" href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_arr__conic__traits__2.html">Arr_conic_traits_2</a></code> class that handles the projected intersection curves. The program reads a set of spheres from an input file and constructs their lower envelope:</p>
<p><br>
<b>File</b> <a class="el" href="_envelope_3_2envelope_spheres_8cpp-example.html">Envelope_3/envelope_spheres.cpp</a> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// Constructing the lower envelope of a set of spheres read from a file.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/config.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef CGAL_USE_CORE</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Sorry, this example needs CORE ..."</span> &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/CORE_algebraic_number_traits.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Arr_conic_traits_2.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Env_sphere_traits_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/envelope_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Nt_traits = <a class="code hl_classRef" href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_c_o_r_e__algebraic__number__traits.html">CGAL::CORE_algebraic_number_traits</a>;</div>
<div class="line"><span class="keyword">using </span>Rational = Nt_traits::Rational;</div>
<div class="line"><span class="keyword">using </span>Algebraic = Nt_traits::Algebraic;</div>
<div class="line"><span class="keyword">using </span>Rat_kernel = <a class="code hl_structRef" href="../Kernel_23/struct_c_g_a_l_1_1_cartesian.html">CGAL::Cartesian&lt;Rational&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Rat_point_3 = Rat_kernel::Point_3;</div>
<div class="line"><span class="keyword">using </span>Alg_kernel = <a class="code hl_structRef" href="../Kernel_23/struct_c_g_a_l_1_1_cartesian.html">CGAL::Cartesian&lt;Algebraic&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Conic_traits_2 =</div>
<div class="line">  <a class="code hl_classRef" href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_arr__conic__traits__2.html">CGAL::Arr_conic_traits_2&lt;Rat_kernel, Alg_kernel, Nt_traits&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Traits_3 = <a class="code hl_class" href="class_c_g_a_l_1_1_env__sphere__traits__3.html">CGAL::Env_sphere_traits_3&lt;Conic_traits_2&gt;</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_sphere__3.html">Sphere_3</a> = Traits_3::Surface_3;</div>
<div class="line"><span class="keyword">using </span>Envelope_diagram_2 = <a class="code hl_class" href="class_c_g_a_l_1_1_envelope__diagram__2.html">CGAL::Envelope_diagram_2&lt;Traits_3&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">  <span class="comment">// Get the name of the input file from the command line, or use the default</span></div>
<div class="line">  <span class="comment">// fan_grids.dat file if no command-line parameters are given.</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* filename = (argc &gt; 1) ? argv[1] : <span class="stringliteral">"spheres.dat"</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Open the input file.</span></div>
<div class="line">  std::ifstream in_file(filename);</div>
<div class="line">  <span class="keywordflow">if</span> (! in_file.is_open()) {</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">"Failed to open "</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">" ..."</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read the spheres from the file.</span></div>
<div class="line">  <span class="comment">// The input file format should be (all coordinate values are integers):</span></div>
<div class="line">  <span class="comment">// &lt;n&gt;                           // number of spheres.</span></div>
<div class="line">  <span class="comment">// &lt;x_1&gt; &lt;y_1&gt; &lt;x_1&gt; &lt;R_1&gt;       // center and squared radious of sphere #1.</span></div>
<div class="line">  <span class="comment">// &lt;x_2&gt; &lt;y_2&gt; &lt;x_2&gt; &lt;R_2&gt;       // center and squared radious of sphere #2.</span></div>
<div class="line">  <span class="comment">//   :     :     :     :</span></div>
<div class="line">  <span class="comment">// &lt;x_n&gt; &lt;y_n&gt; &lt;x_n&gt; &lt;R_n&gt;       // center and squared radious of sphere #n.</span></div>
<div class="line">  <span class="keywordtype">int</span> n = 0;</div>
<div class="line">  std::list&lt;Sphere_3&gt; spheres;</div>
<div class="line">  <span class="keywordtype">int</span> x = 0, y = 0, z = 0, sqr_r = 0;</div>
<div class="line">  in_file &gt;&gt; n;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">    in_file &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; sqr_r;</div>
<div class="line">    spheres.push_back(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_sphere__3.html">Sphere_3</a>(Rat_point_3(x, y, z), Rational(sqr_r)));</div>
<div class="line">  }</div>
<div class="line">  in_file.close();</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Constructing the lower envelope of "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">" spheres.\n"</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute the lower envelope.</span></div>
<div class="line">  Envelope_diagram_2 min_diag;</div>
<div class="line">  <span class="keyword">auto</span> start = std::chrono::system_clock::now();</div>
<div class="line">  <a class="code hl_function" href="group___pkg_envelope3_ref.html#gafd8dc9fadb187466e4c567099ec1a443">CGAL::lower_envelope_3</a>(spheres.begin(), spheres.end(), min_diag);</div>
<div class="line">  std::chrono::duration&lt;double&gt; secs = std::chrono::system_clock::now() - start;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Print the dimensions of the minimization diagram.</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"V = "</span> &lt;&lt; min_diag.number_of_vertices()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">", E = "</span> &lt;&lt; min_diag.number_of_edges()</div>
<div class="line">            &lt;&lt; <span class="stringliteral">", F = "</span> &lt;&lt; min_diag.number_of_faces() &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Construction took "</span> &lt;&lt; secs.count() &lt;&lt; <span class="stringliteral">" seconds.\n"</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_arr__conic__traits__2_html"><div class="ttname"><a href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_arr__conic__traits__2.html">CGAL::Arr_conic_traits_2</a></div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_c_o_r_e__algebraic__number__traits_html"><div class="ttname"><a href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_c_o_r_e__algebraic__number__traits.html">CGAL::CORE_algebraic_number_traits</a></div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_env__sphere__traits__3_html"><div class="ttname"><a href="class_c_g_a_l_1_1_env__sphere__traits__3.html">CGAL::Env_sphere_traits_3</a></div><div class="ttdoc">The traits class Env_sphere_traits_3 models the EnvelopeTraits_3 concept, and is used for the constru...</div><div class="ttdef"><b>Definition:</b> Env_sphere_traits_3.h:32</div></div>
<div class="ttc" id="aclass_kernel_1_1_sphere__3_html"><div class="ttname"><a href="../Kernel_23/class_kernel_1_1_sphere__3.html">Kernel::Sphere_3</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="Envelope_3ExampleforEnvelopeofPlanes"></a>
Example for Envelope of Planes</h2>
<p>The next example demonstrates how to instantiate and use the envelope-traits class for planes, based on the <code><a class="elRef" href="../Arrangement_on_surface_2/class_c_g_a_l_1_1_arr__linear__traits__2.html">Arr_linear_traits_2</a></code> class that handles infinite linear objects such as lines and rays.</p>
<p><br>
<b>File</b> <a class="el" href="_envelope_3_2envelope_planes_8cpp-example.html">Envelope_3/envelope_planes.cpp</a> </p><div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// Constructing the lower and the upper envelope of a set of planes.</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_rational.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Cartesian.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Env_plane_traits_3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/envelope_3.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span>Number_type = CGAL::Exact_rational;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_namespaceRef" href="../Kernel_23/namespace_kernel.html">Kernel</a> = <a class="code hl_structRef" href="../Kernel_23/struct_c_g_a_l_1_1_cartesian.html">CGAL::Cartesian&lt;Number_type&gt;</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_plane__3.html">Plane_3</a> = <a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_plane__3.html">Kernel::Plane_3</a>;</div>
<div class="line"><span class="keyword">using </span>Traits_3 = <a class="code hl_class" href="class_c_g_a_l_1_1_env__plane__traits__3.html">CGAL::Env_plane_traits_3&lt;Kernel&gt;</a>;</div>
<div class="line"><span class="keyword">using </span>Surface_3 = Traits_3::Surface_3;</div>
<div class="line"><span class="keyword">using </span>Envelope_diagram_2 = <a class="code hl_class" href="class_c_g_a_l_1_1_envelope__diagram__2.html">CGAL::Envelope_diagram_2&lt;Traits_3&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Auxiliary function - print the features of the given envelope diagram. */</span></div>
<div class="line"><span class="keywordtype">void</span> print_diagram(<span class="keyword">const</span> Envelope_diagram_2&amp; diag) {</div>
<div class="line">  <span class="comment">// Go over all arrangement faces.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> fit = diag.faces_begin(); fit != diag.faces_end(); ++fit) {</div>
<div class="line">    <span class="comment">// Print the face boundary.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print the vertices along the outer boundary of the face.</span></div>
<div class="line">    <span class="keyword">auto</span> ccb = fit-&gt;outer_ccb();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"[Face] "</span>;</div>
<div class="line">    <span class="keywordflow">do</span> <span class="keywordflow">if</span> (!ccb-&gt;is_fictitious()) std::cout &lt;&lt; <span class="charliteral">'('</span> &lt;&lt; ccb-&gt;curve() &lt;&lt; <span class="stringliteral">") "</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (++ccb != fit-&gt;outer_ccb());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Print the planes that induce the envelope on this face.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">"--&gt; "</span> &lt;&lt; fit-&gt;number_of_surfaces() &lt;&lt; <span class="stringliteral">" planes:"</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> sit = fit-&gt;surfaces_begin(); sit != fit-&gt;surfaces_end(); ++sit)</div>
<div class="line">      std::cout &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; sit-&gt;plane();</div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* The main program: */</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="comment">// Construct the input planes.</span></div>
<div class="line">  std::list&lt;Surface_3&gt; planes;</div>
<div class="line"> </div>
<div class="line">  planes.push_back(Surface_3(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_plane__3.html">Plane_3</a>(0, -1, 1, 0)));</div>
<div class="line">  planes.push_back(Surface_3(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_plane__3.html">Plane_3</a>(-1, 0, 1, 0)));</div>
<div class="line">  planes.push_back(Surface_3(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_plane__3.html">Plane_3</a>(0, 1 , 1, 0)));</div>
<div class="line">  planes.push_back(Surface_3(<a class="code hl_classRef" href="../Kernel_23/class_kernel_1_1_plane__3.html">Plane_3</a>(1, 0, 1,  0)));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute and print the minimization diagram.</span></div>
<div class="line">  Envelope_diagram_2 min_diag;</div>
<div class="line">  <a class="code hl_function" href="group___pkg_envelope3_ref.html#gafd8dc9fadb187466e4c567099ec1a443">CGAL::lower_envelope_3</a>(planes.begin(), planes.end(), min_diag);</div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"The minimization diagram:"</span> &lt;&lt; std::endl;</div>
<div class="line">  print_diagram(min_diag);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Compute and print the maximization diagram.</span></div>
<div class="line">  Envelope_diagram_2 max_diag;</div>
<div class="line">  <a class="code hl_function" href="group___pkg_envelope3_ref.html#ga1fbbe89e27c3dc3404bbbb3b1f7ceea1">CGAL::upper_envelope_3</a>(planes.begin(), planes.end(), max_diag);</div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">"The maximization diagram:"</span> &lt;&lt; std::endl;</div>
<div class="line">  print_diagram (max_diag);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_env__plane__traits__3_html"><div class="ttname"><a href="class_c_g_a_l_1_1_env__plane__traits__3.html">CGAL::Env_plane_traits_3</a></div><div class="ttdoc">The traits class template Env_plane_traits_3 models the EnvelopeTraits_3 concept, and is used for the...</div><div class="ttdef"><b>Definition:</b> Env_plane_traits_3.h:38</div></div>
<div class="ttc" id="aclass_kernel_1_1_plane__3_html"><div class="ttname"><a href="../Kernel_23/class_kernel_1_1_plane__3.html">Kernel::Plane_3</a></div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>


</html>
