<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://doc.cgal.org/latest/Polynomial/index.html"/>

<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=11">
<meta name="generator" content="Doxygen 1.9.6">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>CGAL 6.0 - Polynomial: User Manual</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/doxygen.css" rel="stylesheet" type="text/css">
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="modules.js" type="text/javascript"></script>
<link href="cgal_stylesheet.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
      <span class="left">
         <span id="MSearchSelect" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()">Â 
        </span>
        <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S" onfocus="searchBox.OnSearchFieldFocus(true)" onblur="searchBox.OnSearchFieldFocus(false)" onkeyup="searchBox.OnSearchFieldChange(event)">
      </span>
      <span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.svg" alt=""></a>
      </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CGAL 6.0 - Polynomial
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search/",'.html');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()" onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync" style="display: none"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">User Manual </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="Chapter_Polynomial"></a><a class="anchor" id="ChapterPolynomial"></a></p> <div id="autotoc" class="toc"></div>  <dl class="section author"><dt>Author</dt><dd>Michael Hemmer</dd></dl>
<h1><a class="anchor" id="PolynomialFundamentals"></a>
Fundamentals</h1>
<p>Note that this is just a very brief introduction to polynomials. For a quick reference we refer to the Wikipedia or for a more elaborate introduction to any class book on elementary algebra.</p>
<p>A <em>polynomial</em> is either zero, or can be written as the sum of one or more non-zero <em>terms</em>. The number of terms is finite. A term consist of a constant <em>coefficient</em> and a <em>monomial</em>, that is, the product of zero or more variables. Each variable may have an exponent that is a non-negative integer. The exponent on a variable in a term is equal to the <em>degree</em> of that variable in that term. A term with no variables is called a constant term. The degree of a constant term is 0.</p>
<p>For example, \( -7x^3y\) is a term. The coefficient is \( -7\), the monomial is \( x^3y\), comprised of the variables \( x\) and \( y\), the degree of \( x\) is three, and the degree of \( y\) is one. The <em>total degree</em> of the entire term is the sum of the degrees in each variable. In the example above, the degree is \( 3 + 1 = 4\).</p>
<p>A one-variable (univariate) polynomial \( f\) of degree \( n\) has the following form:</p>
<p class="formulaDsp">
\[ f = a_nx^n + a_{n-1}x^{n-1} + ... + a_2x^2 + a_1x + a_0 \]
</p>
<p>The coefficient \( a_0\) is called the <em>constant coefficient</em>, \( a_n\) is called the <em>leading coefficient</em>. If \( f\) is not the zero polynomial the leading coefficient is not zero. The polynomial is called monic if \( a_n = 1\). In case the coefficient domain of \( f\) possess a greatest common divisor (gcd) the <em>content</em> of \( f\) is the gcd of all coefficients of \( f\). For instance, the content of \( 12 x^3 + 6\) is \( 6\).</p>
<p>A multivariate polynomial is a polynomial in more than one variable. According to the number of variables it is possible to further classify multivariate polynomials as bivariate, trivariate etc. In contrast to univariate polynomials the terms of a multivariate polynomial are not completely ordered by their total degree. However, given a certain order on the variables it is possible to define a lexicographic order on the terms. Given this order the leading coefficient of a multivariate polynomial is defined as the coefficient of the highest term. For instance the leading coefficient of the multivariate polynomial \( p = 5 x^3y + 7xy^2\) is \( 7\), given that \( y\) has an higher order than \( x\).</p>
<p>However, it is also possible to interpret a multivariate polynomial as a univariate polynomial in that variable. For instance the trivariate polynomial </p><p class="formulaDsp">
\[ q = x^5 + 7x^2y^1z^2 + 13x^1y^2z^2 \in \Z[x,y,z] \]
</p>
<p> may be interpreted as a univariate polynomial in \( z\), that is, \( q\) is interpreted as an element of \( R[z]\), with \( R=\Z[x,y]\). </p><p class="formulaDsp">
\[ q = (13x^1y^2 + 7x^2y^1)z^2 + x^5z^0 \in R[z] \]
</p>
<p> In this case the leading coefficient of \( q\) with respect to \( z\) is \( 13x^1y^2 + 7x^2y^1\) and \( x^5\) becomes the 'constant' term.</p>
<p>A <em>homogeneous polynomial</em> is a polynomial whose terms do all have the same total degree. For example, \( h = x^5 + 7x^2y^1z^2 + 13x^1y^2z^2\) is a homogeneous polynomial of degree \( 5\), in three variables.</p>
<h1><a class="anchor" id="PolynomialGeneral"></a>
General Design</h1>
<p>The package introduces a concept <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code>, a concept for multivariate polynomials in \( d\) variables. Though the concept is written for an arbitrary number of variables, the number of variables is considered as fixed for a particular model of <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code>. The concept also allows univariate polynomials.</p>
<p>First of all a model of <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code> is considered as an algebraic structure, that is, the ring operations \( \{+, -, \cdot\}\) are provided due to the fact that <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code> refines at least the concept <code><a class="elRef" href="../Algebraic_foundations/class_integral_domain_without_division.html">IntegralDomainWithoutDivision</a></code>. However, a model of <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code> has to be accompanied by a traits class <code><a class="el" href="class_c_g_a_l_1_1_polynomial__traits__d.html" title="A model of concept PolynomialTraits_d">Polynomial_traits_d</a>&lt;<a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a>&gt;</code> being a model of <code><a class="el" href="class_polynomial_traits__d.html" title="A model of PolynomialTraits_d is associated with a type Polynomial_d. The type Polynomial_d represent...">PolynomialTraits_d</a></code>. This traits class provides all further functionalities on polynomials.</p>
<p>Given a \( d\)-variate polynomial over some base ring \( R\) there are at least two different possible views on such a polynomial. </p><ul>
<li>
The recursive or univariate view: In this view, a polynomial is considered as an element of \( R[x_0,\dots,x_{d-2}][x_{d-1}]\). That is, the polynomial is treated as a univariate polynomial over the ring \( R[x_0,\dots,x_{d-2}]\). </li>
<li>
The symmetric or multivariate view: This view is almost symmetric with respect to all variables. It considers the polynomial as an element of \( R [x_0,\dots,x_{d-1}]\). </li>
</ul>
<p>According to these two different views the traits class is required to provide two different coefficient types: </p><ul>
<li>
<code>Polynomial_traits_d::Coefficient_type</code> representing \( R[x_0,\dots,x_{d-2}]\). </li>
<li>
<code>Polynomial_traits_d::Innermost_coefficient_type</code> representing the base ring \( R\). </li>
</ul>
<p>Another important type which is introduced by this package is <code><a class="el" href="class_c_g_a_l_1_1_exponent__vector.html" title="For a given (multivariate) monomial the vector of its exponents is called the exponent vector.">Exponent_vector</a></code>. It is derived from <code>std::vector&lt;int&gt;</code> and used to identify multivariate monomials. For instance the exponent vector containing the sequence \( [3,2,4]\) corresponds to the trivariate monomial \( x_0^3x_1^2x_2^4\). Note that a vector with negative exponents is considered as invalid. However, we allow negative exponents as they may appear as intermediate results, in particular we did <em>not</em> derive from <code>std::vector&lt;unsigned int&gt;</code>.</p>
<h1><a class="anchor" id="PolynomialConstructing"></a>
Constructing a Multivariate Polynomial</h1>
<p>First of all the concept <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code> requires that the model is constructible from int. This is due to the fact that <code><a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a></code> refines <code><a class="elRef" href="../Algebraic_foundations/class_integral_domain_without_division.html">IntegralDomainWithoutDivision</a></code> which in turn refines <code><a class="elRef" href="../Algebraic_foundations/class_from_int_constructible.html">FromIntConstructible</a></code>. Of course this allows only the construction of constant polynomials.</p>
<p>In general a polynomial is constructed using the functor <code>Polynomial_traits_d::Construct_polynomial</code> a model of <code><a class="el" href="class_polynomial_traits__d_1_1_construct_polynomial.html" title="This AdaptableFunctor provides several operators to construct objects of type PolynomialTraits_d::Pol...">PolynomialTraits_d::ConstructPolynomial</a></code>. Basically there are two options: </p><ul>
<li>
The polynomial is constructed from an iterator range with value type <code>Polynomial_traits_d::Coefficient_type</code>, where the <code>begin</code> iterator refers to the constant term (constant with respect to the outermost variable). </li>
<li>
The polynomial is constructed from an iterator range with value type <code>std::pair&lt;<a class="el" href="class_c_g_a_l_1_1_exponent__vector.html" title="For a given (multivariate) monomial the vector of its exponents is called the exponent vector.">Exponent_vector</a>, Polynomial_traits_d::Innermost_coefficient_type&gt;</code>, where each pair defines the coefficient for the monomial defined by the exponent vector. </li>
</ul>
<p>However, in some cases it might be more convenient to just construct the polynomials representing the different variables and to obtain the final polynomial using algebraic expressions. The most elegant way to construct a certain variable is <code>Polynomial_traits_d::Shift</code> being a model of <code><a class="el" href="class_polynomial_traits__d_1_1_shift.html" title="This AdaptableBinaryFunction multiplies a PolynomialTraits_d::Polynomial_d by the given power of the ...">PolynomialTraits_d::Shift</a></code>.</p>
<h2><a class="anchor" id="PolynomialExample"></a>
Example</h2>
<p>The following example illustrates different ways to construct a bivariate polynomial: <br>
<b>File</b> <a class="el" href="_polynomial_2construction_8cpp-example.html">Polynomial/construction.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</a> Poly_2;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</a>            PT_2;</div>
<div class="line">  <span class="keyword">typedef</span> PT_2::Coefficient_type                       Poly_1;</div>
<div class="line">  <span class="keyword">typedef</span> PT_2::Innermost_coefficient_type             Integer;</div>
<div class="line"> </div>
<div class="line">  PT_2::Construct_polynomial construct_polynomial;</div>
<div class="line">  Poly_2 dc;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// constructing a constant polynomial from int</span></div>
<div class="line">  Poly_2 two(2); <span class="comment">// = 2</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"A constant polynomial: "</span> &lt;&lt; two &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construction from an iterator range of univariate polynomials</span></div>
<div class="line"> </div>
<div class="line">  std::list&lt;Poly_1&gt; univariate_coeffs;</div>
<div class="line">  univariate_coeffs.push_back(Poly_1(3));</div>
<div class="line">  univariate_coeffs.push_back(Poly_1(0));</div>
<div class="line">  univariate_coeffs.push_back(Poly_1(5));</div>
<div class="line">  Poly_2 F = <span class="comment">// 5*y^2 + 3</span></div>
<div class="line">    construct_polynomial(univariate_coeffs.begin(),univariate_coeffs.end());</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial F: "</span> &lt;&lt; F &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="comment">// construction from an iterator range over monomials</span></div>
<div class="line"> </div>
<div class="line">  std::list&lt;std::pair&lt;CGAL::Exponent_vector, Integer&gt; &gt; innermost_coeffs;</div>
<div class="line">  innermost_coeffs.push_back(std::make_pair(<a class="code hl_class" href="class_c_g_a_l_1_1_exponent__vector.html">CGAL::Exponent_vector</a>(0,0),-2));</div>
<div class="line">  innermost_coeffs.push_back(std::make_pair(<a class="code hl_class" href="class_c_g_a_l_1_1_exponent__vector.html">CGAL::Exponent_vector</a>(3,5),2));</div>
<div class="line">  Poly_2 G = <span class="comment">// (2*x^3)*y^5 + (-2)</span></div>
<div class="line">    construct_polynomial(innermost_coeffs.begin(),innermost_coeffs.end());</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial G: "</span> &lt;&lt; G &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  PT_2::Shift <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaea3cc897abde3d46a502aeff8aae4c8f">shift</a>;</div>
<div class="line">  Poly_2 x = <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaea3cc897abde3d46a502aeff8aae4c8f">shift</a>(Poly_2(1),1,0); <span class="comment">// 'multiply' 1 by x_0^1</span></div>
<div class="line">  Poly_2 y = <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaea3cc897abde3d46a502aeff8aae4c8f">shift</a>(Poly_2(1),1,1); <span class="comment">// 'multiply' 1 by x_1^1</span></div>
<div class="line"> </div>
<div class="line">  Poly_2 H = 5 * x * y + 3 * y * y; <span class="comment">// = 3*y^2 + (5*x)*y</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial H: "</span> &lt;&lt; H &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclass_c_g_a_l_1_1_exponent__vector_html"><div class="ttname"><a href="class_c_g_a_l_1_1_exponent__vector.html">CGAL::Exponent_vector</a></div><div class="ttdoc">For a given (multivariate) monomial the vector of its exponents is called the exponent vector.</div><div class="ttdef"><b>Definition:</b> Exponent_vector.h:30</div></div>
<div class="ttc" id="aclass_c_g_a_l_1_1_polynomial__traits__d_html"><div class="ttname"><a href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d</a></div><div class="ttdoc">A model of concept PolynomialTraits_d</div><div class="ttdef"><b>Definition:</b> Polynomial_traits_d.h:13</div></div>
<div class="ttc" id="aclassunspecified__type_html"><div class="ttname"><a href="../Manual/classunspecified__type.html">unspecified_type</a></div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_gaea3cc897abde3d46a502aeff8aae4c8f"><div class="ttname"><a href="group___pkg_polynomial_functions.html#gaea3cc897abde3d46a502aeff8aae4c8f">CGAL::shift</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Shift::result_type shift(const Polynomial_d &amp;p, int i, int index=Polynomial_traits_d&lt; Polynomial_d &gt;::d-1)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
<div class="ttc" id="agroup___pkg_stream_support_ref_html_ga2cbb865dd83eedd780f4a452635b1d28"><div class="ttname"><a href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a></div><div class="ttdeci">Mode set_pretty_mode(std::ios &amp;s)</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialCoefficient"></a>
Coefficient Access</h1>
<p>In order to obtain a certain coefficient the traits class provides several functors. Note that the functors do not allow a write access to the coefficients. </p><ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_get_coefficient.html" title="This AdaptableBinaryFunction provides access to coefficients of a PolynomialTraits_d::Polynomial_d.">PolynomialTraits_d::GetCoefficient</a></code>: a model of this concept provides access to a coefficient in the univariate view, that is, it returns elements of \( R[x_0,\dots,x_{d-2}]\). </li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_get_innermost_coefficient.html" title="For the given PolynomialTraits_d::Polynomial_d this AdaptableBinaryFunction returns the coefficient o...">PolynomialTraits_d::GetInnermostCoefficient</a></code>: a model of this concept provides access to a coefficient in the multivariate view, that is, it returns elements of \( R\). </li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_leading_coefficient.html" title="This AdaptableUnaryFunction computes the leading coefficient of a PolynomialTraits_d::Polynomial_d.">PolynomialTraits_d::LeadingCoefficient</a></code>: a model of this concept provides access to the leading coefficient in the univariate view. </li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_innermost_leading_coefficient.html" title="This AdaptableUnaryFunction computes the innermost leading coefficient of a PolynomialTraits_d::Polyn...">PolynomialTraits_d::InnermostLeadingCoefficient</a></code>: a model of this concept provides access to the leading coefficient in the multivariate view, that is, it returns the (innermost) coefficient of the leading multivariate monomial. See also <code><a class="el" href="class_polynomial_traits__d_1_1_degree_vector.html" title="For a given PolynomialTraits_d::Polynomial_d  this AdaptableUnaryFunction returns the degree vector,...">PolynomialTraits_d::DegreeVector</a></code>. </li>
</ul>
<h2><a class="anchor" id="PolynomialExample_1"></a>
Example</h2>
<p>The following example illustrates the application of the functors discussed above: <br>
<b>File</b> <a class="el" href="_polynomial_2coefficient_access_8cpp-example.html">Polynomial/coefficient_access.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</a> Poly_2;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</a>            PT_2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  Poly_2 x = PT_2::Shift()(Poly_2(1),1,0); <span class="comment">// = x^1</span></div>
<div class="line">  Poly_2 y = PT_2::Shift()(Poly_2(1),1,1); <span class="comment">// = y^1</span></div>
<div class="line"> </div>
<div class="line">  Poly_2 F <span class="comment">// = (11*x^2 + 5*x)*y^4 + (7*x^2)*y^3</span></div>
<div class="line">    = 11 * CGAL::ipower(y,4) * CGAL::ipower(x,2)</div>
<div class="line">    + 5 * CGAL::ipower(y,4)  * CGAL::ipower(x,1)</div>
<div class="line">    + 7 * CGAL::ipower(y,3)  * CGAL::ipower(x,2);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial F: "</span> &lt;&lt; F &lt;&lt;<span class="stringliteral">"\n"</span>&lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_2::Get_coefficient <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coefficient of y^0: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>(F,0) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coefficient of y^1: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>(F,1) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coefficient of y^2: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>(F,2) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coefficient of y^3: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>(F,3) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coefficient of y^4: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>(F,4) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Coefficient of y^5: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">get_coefficient</a>(F,5) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_2::Leading_coefficient lcoeff;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Leading coefficient with respect to y:           "</span></div>
<div class="line">            &lt;&lt; lcoeff(F)   <span class="comment">// = 11*x^2 + 5*x</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_2::Get_innermost_coefficient get_icoeff;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Innermost coefficient of monomial x^1y^4:        "</span></div>
<div class="line">            &lt;&lt; get_icoeff(F,<a class="code hl_class" href="class_c_g_a_l_1_1_exponent__vector.html">CGAL::Exponent_vector</a>(1,4)) <span class="comment">// = 5</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_2::Innermost_leading_coefficient ilcoeff;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Innermost leading coefficient with respect to y: "</span></div>
<div class="line">            &lt;&lt; ilcoeff(F) <span class="comment">// = 11</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga8803637196a44763d39fe3a264141699"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga8803637196a44763d39fe3a264141699">CGAL::get_coefficient</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::get_coefficient::result_type get_coefficient(const Polynomial_d &amp;p, int i)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialDegree"></a>
Degree, Total Degree and Degree Vector</h1>
<p>There are three functors in <code><a class="el" href="class_polynomial_traits__d.html" title="A model of PolynomialTraits_d is associated with a type Polynomial_d. The type Polynomial_d represent...">PolynomialTraits_d</a></code> related to the degree of a polynomial. </p><ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_degree.html" title="This AdaptableUnaryFunction computes the degree of a PolynomialTraits_d::Polynomial_d with respect to...">PolynomialTraits_d::Degree</a></code>: a model of this concept returns the degree of the polynomial in the univariate view. By default this is the degree with respect to the outermost variable, but it is also possible to select another variable. </li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_total_degree.html" title="This AdaptableUnaryFunction computes the total degree of a PolynomialTraits_d::Polynomial_d.">PolynomialTraits_d::TotalDegree</a></code>: a model of this concept returns the <em>total degree</em> of a polynomial. The polynomial is considered as a multivariate polynomial. The total degree is the maximum over the sums of the exponents of each multivariate monomial. </li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_degree_vector.html" title="For a given PolynomialTraits_d::Polynomial_d  this AdaptableUnaryFunction returns the degree vector,...">PolynomialTraits_d::DegreeVector</a></code>: a model of this concept returns the exponent vector of the leading monomial, where the monomial order is lexicographic and starts with the outermost variable. See also <code><a class="el" href="class_polynomial_traits__d_1_1_innermost_leading_coefficient.html" title="This AdaptableUnaryFunction computes the innermost leading coefficient of a PolynomialTraits_d::Polyn...">PolynomialTraits_d::InnermostLeadingCoefficient</a></code>. </li>
</ul>
<h2><a class="anchor" id="PolynomialExample_2"></a>
Example</h2>
<p>The following example illustrates the application of the functors discussed above: <br>
<b>File</b> <a class="el" href="_polynomial_2degree_8cpp-example.html">Polynomial/degree.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</a> Poly_2;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</a>            PT_2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  Poly_2 x = PT_2::Shift()(Poly_2(1),1,0); <span class="comment">// x_0^1</span></div>
<div class="line">  Poly_2 y = PT_2::Shift()(Poly_2(1),1,1); <span class="comment">// x_1^1</span></div>
<div class="line"> </div>
<div class="line">  Poly_2 F <span class="comment">// = (11*x^2 + 5*x)*y^4 + (7*x^2)*y^3</span></div>
<div class="line">    = 11 * CGAL::ipower(y,4) * CGAL::ipower(x,2)</div>
<div class="line">    + 5 * CGAL::ipower(y,4)  * CGAL::ipower(x,1)</div>
<div class="line">    + 7 * CGAL::ipower(y,3)  * CGAL::ipower(x,2);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial F: "</span> &lt;&lt; F &lt;&lt;<span class="stringliteral">"\n"</span>&lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_2::Degree <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf98b5536fa88dbf058ac4f46223ed870">degree</a>;</div>
<div class="line">  PT_2::Total_degree <a class="code hl_function" href="group___pkg_polynomial_functions.html#gac20ebd2ea6b68c5e19225ddc6e9a0e32">total_degree</a>;</div>
<div class="line">  PT_2::Degree_vector <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8281f6beeaf6cdd634336ee01abaffc9">degree_vector</a>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The degree of F with respect to y: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf98b5536fa88dbf058ac4f46223ed870">degree</a>(F)       <span class="comment">// = 4</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The degree of F with respect to x: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf98b5536fa88dbf058ac4f46223ed870">degree</a>(F,0)     <span class="comment">// = 2</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The total degree of F            : "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gac20ebd2ea6b68c5e19225ddc6e9a0e32">total_degree</a>(F) <span class="comment">// = 6</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The degree vector of F           : "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga8281f6beeaf6cdd634336ee01abaffc9">degree_vector</a>(F)<span class="comment">// = (2,4)</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga8281f6beeaf6cdd634336ee01abaffc9"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga8281f6beeaf6cdd634336ee01abaffc9">CGAL::degree_vector</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Degree_vector::result_type degree_vector(const Polynomial_d &amp;p)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_gac20ebd2ea6b68c5e19225ddc6e9a0e32"><div class="ttname"><a href="group___pkg_polynomial_functions.html#gac20ebd2ea6b68c5e19225ddc6e9a0e32">CGAL::total_degree</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Total_degree::result_type total_degree(const Polynomial_d &amp;p)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_gaf98b5536fa88dbf058ac4f46223ed870"><div class="ttname"><a href="group___pkg_polynomial_functions.html#gaf98b5536fa88dbf058ac4f46223ed870">CGAL::degree</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Degree::result_type degree(const Polynomial_d &amp;p, int i, index=Polynomial_traits_d&lt; Polynomial_d &gt;::d-1)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialChanging"></a>
Changing the Order of Variables</h1>
<p>Given for instance a bivariate polynomial it is conceivable that one wants to interchange the role of \( x\) and \( y\). That is one wants to interpret the \( x\) as \( y\) and vice versa. For such a case the polynomial traits provides <code><a class="el" href="class_polynomial_traits__d_1_1_swap.html" title="This AdaptableFunctor swaps two variables of a multivariate polynomial.">PolynomialTraits_d::Swap</a></code>:</p>
<p>Given a polynomial \( p\) and to two indices \( i\) and \( j\), the functor returns the polynomial in which \( x_i\) is substituted by \( x_j\) and vice versa, that is, the variables swap their positions. The order of the other variables remains untouched.</p>
<p>Another scenario is, that a particular variable should be moved to another position, for instance, it should become the outermost variable while the relative order of the other variables remains unchanged. For such a case the polynomial traits provides <code><a class="el" href="class_polynomial_traits__d_1_1_move.html" title="This AdaptableFunctor moves a variable at position  to a new position . The relative order of the oth...">PolynomialTraits_d::Move</a></code>.</p>
<p>Of course there is also a general method to interchange the order of variables, namely <code><a class="el" href="class_polynomial_traits__d_1_1_permute.html" title="This AdaptableFunctor permutes the variables of the given polynomial with respect to a permutation ,...">PolynomialTraits_d::Permute</a></code>.</p>
<h2><a class="anchor" id="PolynomialExample_3"></a>
Example</h2>
<p>The following example illustrates the application of the functors discussed above: <br>
<b>File</b> <a class="el" href="_polynomial_2swap_move_8cpp-example.html">Polynomial/swap_move.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;int,3&gt;::Type</a> Poly_3;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_3&gt;</a>            PT_3;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  Poly_3 x = PT_3::Shift()(Poly_3(1),1,0); <span class="comment">// x_0^1</span></div>
<div class="line">  Poly_3 y = PT_3::Shift()(Poly_3(1),1,1); <span class="comment">// x_1^1</span></div>
<div class="line">  Poly_3 z = PT_3::Shift()(Poly_3(1),1,2); <span class="comment">// x_2^1</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Poly_3 F = x*y*y*z*z*z;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The trivariate polynomial F: "</span> &lt;&lt; F &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_3::Swap <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf14eb69ab0be30e7ecec826374296279">swap</a>;</div>
<div class="line">  PT_3::Move <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga3c9844416f0d3ed43923d2a4892b5813">move</a>;</div>
<div class="line">  PT_3::Permute <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf50ef88b24f772d61eefbab49015aeb4">permute</a>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"x and z swapped: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf14eb69ab0be30e7ecec826374296279">swap</a>(F,0,2) <span class="comment">// = x^3*y^2*z</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"x and y swapped: "</span>&lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf14eb69ab0be30e7ecec826374296279">swap</a>(F,0,1) <span class="comment">// = x^2*y*z^3</span></div>
<div class="line">            &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"x moved to outermost position           : "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga3c9844416f0d3ed43923d2a4892b5813">move</a>(F,0,2)                       <span class="comment">// = x^2*y^3*z</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Same as swap(swap(F,0,1),1,2)           : "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf14eb69ab0be30e7ecec826374296279">swap</a>(<a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf14eb69ab0be30e7ecec826374296279">swap</a>(F,0,1),1,2)             <span class="comment">// = x^2*y^3*z</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Same as the permutation (0,1,2)-&gt;(2,0,1): "</span>;</div>
<div class="line">  std::vector&lt;int&gt; perm;</div>
<div class="line">  perm.push_back(2);perm.push_back(0);perm.push_back(1);</div>
<div class="line">  std::cout &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaf50ef88b24f772d61eefbab49015aeb4">permute</a>(F,perm.begin(),perm.end())<span class="comment">// = x^2*y^3*z</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga3c9844416f0d3ed43923d2a4892b5813"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga3c9844416f0d3ed43923d2a4892b5813">CGAL::move</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Move::result_type move(const Polynomial_d &amp;p, int i, int j)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_gaf14eb69ab0be30e7ecec826374296279"><div class="ttname"><a href="group___pkg_polynomial_functions.html#gaf14eb69ab0be30e7ecec826374296279">CGAL::swap</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Swap::result_type swap(const Polynomial_d &amp;p, int i, int j)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_gaf50ef88b24f772d61eefbab49015aeb4"><div class="ttname"><a href="group___pkg_polynomial_functions.html#gaf50ef88b24f772d61eefbab49015aeb4">CGAL::permute</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Permute::result_type permute(const Polynomial_d &amp;p, InputIterator begin, InputIterator end)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialGCD"></a>
GCD and More</h1>
<p>Since the concept <code><a class="el" href="class_polynomial_traits__d.html" title="A model of PolynomialTraits_d is associated with a type Polynomial_d. The type Polynomial_d represent...">PolynomialTraits_d</a></code> refines the concept <code><a class="elRef" href="../Algebraic_foundations/class_algebraic_structure_traits.html">AlgebraicStructureTraits</a></code> the polynomial traits provides functors for integral division, division with remainder, greatest common divisor, etc. But note that the algebraic structure of a polynomial depends on the algebraic structure of the innermost coefficient, for instance, a gcd is available if and only if the innermost coefficient is a <code><a class="elRef" href="../Algebraic_foundations/class_field.html">Field</a></code> or a <code><a class="elRef" href="../Algebraic_foundations/class_unique_factorization_domain.html">UniqueFactorizationDomain</a></code>. Hence, we can not provide a \( gcd\) if the innermost coefficient is just an <code><a class="elRef" href="../Algebraic_foundations/class_integral_domain.html">IntegralDomain</a></code> since it is simply not well defined<span class="footnote">An example for such a number type is the template S<code style="display:inline">qrt_extension&lt;NT,ROOT&gt;</code> representing an algebraic extension of degree two. This is just an <code style="display:inline"><a class="elRef" href="../Algebraic_foundations/class_integral_domain.html">IntegralDomain</a></code> if NT is not a <code><a class="elRef" href="../Algebraic_foundations/class_field.html">Field</a></code>. </span>. However, if we would consider the polynomial over the quotient field of the integral domain the \( gcd\) would be well defined. The only problem is that the result can not be represented over the ring since it contains denominators. Therefore, the <code><a class="el" href="class_polynomial_traits__d.html" title="A model of PolynomialTraits_d is associated with a type Polynomial_d. The type Polynomial_d represent...">PolynomialTraits_d</a></code> requires functors such as <code><a class="el" href="class_polynomial_traits__d_1_1_gcd_up_to_constant_factor.html" title="This AdaptableBinaryFunction computes the  up to a constant factor (utcf) of two polynomials of type ...">PolynomialTraits_d::GcdUpToConstantFactor</a></code>. This functor computes the gcd of two polynomials up to a constant factor (utcf). That is, it returns the correct gcd for polynomials over the quotient field, but multiplied by some constant such that the result is representable with coefficients in the ring.</p>
<p>However, note that these 'utcf' functions are usually a bit faster than their strict counterparts. This is due to the fact that the 'utcf' functions are allowed to skip the computation of the correct constant factor. Note that in many cases the constant factor is in fact not needed. In particular if the polynomials are supposed to represent some zero set, that is, an algebraic curve or surface.</p>
<p>The concepts for the related functors are: </p><ul>
<li>
<p class="startli"><code><a class="elRef" href="../Algebraic_foundations/class_algebraic_structure_traits.html#a2e8adafb865d8bb1c2cafb13c8a6ccf3">AlgebraicStructureTraits::Gcd</a></code></p>
<p class="interli"><code><a class="el" href="class_polynomial_traits__d_1_1_gcd_up_to_constant_factor.html" title="This AdaptableBinaryFunction computes the  up to a constant factor (utcf) of two polynomials of type ...">PolynomialTraits_d::GcdUpToConstantFactor</a></code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>AlgebraicStructureTraits::IntegralDivision</code></p>
<p class="interli"><code><a class="el" href="class_polynomial_traits__d_1_1_integral_division_up_to_constant_factor.html" title="This AdaptableBinaryFunction computes the integral division of two polynomials of type PolynomialTrai...">PolynomialTraits_d::IntegralDivisionUpToConstantFactor</a></code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="class_polynomial_traits__d_1_1_univariate_content.html" title="This AdaptableUnaryFunction computes the content of a PolynomialTraits_d::Polynomial_d with respect t...">PolynomialTraits_d::UnivariateContent</a></code></p>
<p class="interli"><code><a class="el" href="class_polynomial_traits__d_1_1_univariate_content_up_to_constant_factor.html" title="This AdaptableUnaryFunction computes the content of a PolynomialTraits_d::Polynomial_d with respect t...">PolynomialTraits_d::UnivariateContentUpToConstantFactor</a></code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code><a class="el" href="class_polynomial_traits__d_1_1_square_free_factorize.html" title="This Functor computes a square-free factorization of a PolynomialTraits_d::Polynomial_d.">PolynomialTraits_d::SquareFreeFactorize</a></code></p>
<p class="endli"><code><a class="el" href="class_polynomial_traits__d_1_1_square_free_factorize_up_to_constant_factor.html" title="This AdaptableFunctor computes a square-free factorization up to a constant factor (utcf) of a Polyno...">PolynomialTraits_d::SquareFreeFactorizeUpToConstantFactor</a></code> </p>
</li>
</ul>
<p>Another analog functionality is the pseudo division. The related functors replace the usual division with remainder in case the <a class="el" href="class_c_g_a_l_1_1_polynomial.html" title="An instance of the data type Polynomial represents a polynomial  from the ring .">Polynomial</a> is not a <code><a class="elRef" href="../Algebraic_foundations/class_euclidean_ring.html">EuclideanRing</a></code>.</p>
<p>The concepts for the related functors are: </p><ul>
<li>
<p class="startli"><code><a class="elRef" href="../Algebraic_foundations/class_algebraic_structure_traits.html#a5126d89547cc79c8d8d315ff93614278">AlgebraicStructureTraits::Div_mod</a></code></p>
<p class="endli"><code><a class="el" href="class_polynomial_traits__d_1_1_pseudo_division.html" title="This AdaptableFunctor computes the pseudo division of two polynomials  and .">PolynomialTraits_d::PseudoDivision</a></code> </p>
</li>
<li>
<p class="startli"><code><a class="elRef" href="../Algebraic_foundations/class_algebraic_structure_traits.html#ad6ede0c3350eafd2fcc2e42e10fecfdc">AlgebraicStructureTraits::Div</a></code></p>
<p class="endli"><code><a class="el" href="class_polynomial_traits__d_1_1_pseudo_division_quotient.html" title="This AdaptableBinaryFunction computes the quotient of the pseudo division of two polynomials  and .">PolynomialTraits_d::PseudoDivisionQuotient</a></code> </p>
</li>
<li>
<p class="startli"><code><a class="elRef" href="../Algebraic_foundations/class_algebraic_structure_traits.html#a83c550874e27c05507c89a976bf32cdf">AlgebraicStructureTraits::Mod</a></code></p>
<p class="endli"><code><a class="el" href="class_polynomial_traits__d_1_1_pseudo_division_remainder.html" title="This AdaptableBinaryFunction computes the remainder of the pseudo division of two polynomials  and .">PolynomialTraits_d::PseudoDivisionRemainder</a></code> </p>
</li>
</ul>
<h2><a class="anchor" id="PolynomialExample_4"></a>
Example</h2>
<p>The following example illustrates the application of some functors discussed above: <br>
<b>File</b> <a class="el" href="_polynomial_2gcd_up_to_constant_factor_8cpp-example.html">Polynomial/gcd_up_to_constant_factor.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;int,1&gt;::Type</a> Poly_1;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_1&gt;</a>            PT_1;</div>
<div class="line"> </div>
<div class="line">  PT_1::Shift                     <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaea3cc897abde3d46a502aeff8aae4c8f">shift</a>;</div>
<div class="line">  PT_1::Gcd                       <a class="code hl_functionRef" href="../Algebraic_foundations/group___pkg_algebraic_foundations_ref.html#gade2b63594fb6827c33c0dcd73b4c7cfe">gcd</a>;</div>
<div class="line">  PT_1::Gcd_up_to_constant_factor gcd_utcf;</div>
<div class="line">  PT_1::Multivariate_content      mcontent;</div>
<div class="line">  PT_1::Canonicalize              <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga3b8b5ea0d228a45fd8491f55e233551d">canonicalize</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  Poly_1 x = <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaea3cc897abde3d46a502aeff8aae4c8f">shift</a>(Poly_1(1),1,0); <span class="comment">// x^1</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// common factor 7 * (x^2-2)</span></div>
<div class="line">  Poly_1 F = 21*(x-5)*(x*x-2); <span class="comment">// = 21*x^3 + (-105)*x^2 + (-42)*x + 210</span></div>
<div class="line">  Poly_1 G = 14*(x-3)*(x*x-2); <span class="comment">// = 14*x^3 + (-42)*x^2 + (-28)*x + 84</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The univariate polynomial F: "</span> &lt;&lt; F &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The univariate polynomial G: "</span> &lt;&lt; G &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Common multivariate content:              "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_functionRef" href="../Algebraic_foundations/group___pkg_algebraic_foundations_ref.html#gade2b63594fb6827c33c0dcd73b4c7cfe">CGAL::gcd</a>(mcontent(F),mcontent(G)) <span class="comment">// = 7</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The gcd of F and G:                       "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_functionRef" href="../Algebraic_foundations/group___pkg_algebraic_foundations_ref.html#gade2b63594fb6827c33c0dcd73b4c7cfe">gcd</a>(F,G)                           <span class="comment">// = 7*x^2 + (-14)</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The gcd up to constant factor of F and G: "</span></div>
<div class="line">            &lt;&lt; gcd_utcf(F,G)                      <span class="comment">// = x^2 + (-2)</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"Same as canonicalized gcd of F and G:     "</span></div>
<div class="line">            &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga3b8b5ea0d228a45fd8491f55e233551d">canonicalize</a>(gcd_utcf(F,G))        <span class="comment">// = x^2 + (-2)</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup___pkg_algebraic_foundations_ref_html_gade2b63594fb6827c33c0dcd73b4c7cfe"><div class="ttname"><a href="../Algebraic_foundations/group___pkg_algebraic_foundations_ref.html#gade2b63594fb6827c33c0dcd73b4c7cfe">CGAL::gcd</a></div><div class="ttdeci">result_type gcd(const NT1 &amp;x, const NT2 &amp;y)</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga3b8b5ea0d228a45fd8491f55e233551d"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga3b8b5ea0d228a45fd8491f55e233551d">CGAL::canonicalize</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Canonicalize::result_type canonicalize(const Polynomial_d &amp;p)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialEvaluation"></a>
Evaluation and Substitution</h1>
<p>Of course, it should also be possible to evaluate a polynomial or substitute its variables. We also require a special functor to determine whether a polynomial is zero at a given point. In case the inner most coefficient is <code><a class="elRef" href="../Algebraic_foundations/class_real_embeddable.html">RealEmbeddable</a></code> the traits also must provide a function to compute the sign at a given point.</p>
<p>The concepts for the related functors are: </p><ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_substitute.html" title="This Functor substitutes all variables of a given multivariate PolynomialTraits_d::Polynomial_d by th...">PolynomialTraits_d::Substitute</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_evaluate.html" title="This AdaptableBinaryFunction evaluates PolynomialTraits_d::Polynomial_d with respect to one variable.">PolynomialTraits_d::Evaluate</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_is_zero_at.html" title="This AdaptableFunctor returns whether a PolynomialTraits_d::Polynomial_d  is zero at a given Cartesia...">PolynomialTraits_d::IsZeroAt</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_sign_at.html" title="This AdaptableFunctor returns the sign of a PolynomialTraits_d::Polynomial_d  at given Cartesian poin...">PolynomialTraits_d::SignAt</a></code> </li>
</ul>
<p>The traits is also required to provide variants of these functors that interpret the polynomial as a homogeneous polynomial by adding a virtual homogeneous variable such that each term has the same degree, namely the degree of the polynomial. Of course there is a difference between the univariate and multivariate view. For instance the polynomial </p><p class="formulaDsp">
\[ 5x^3 + 7x - 3 \]
</p>
<p> has degree 3, hence it is interpreted as the homogeneous polynomial </p><p class="formulaDsp">
\[ 5x^3 + 7xw^2 -3w^3 \]
</p>
<p> by adding the homogeneous variable \( w\). In case of the multivariate view each term is filled up by the homogeneous variable such that the degree of each term is equal to the total degree of the polynomial. Note that these functors may significantly improve efficiency. For instance, it is possible to determine the sign of a polynomial over integer coefficients at a rational point without changing the coefficient domain of the polynomial. For more details have a look at the following concepts: </p><ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_substitute_homogeneous.html" title="This Functor substitutes all variables of a given multivariate PolynomialTraits_d::Polynomial_d  by t...">PolynomialTraits_d::SubstituteHomogeneous</a></code> </li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_evaluate_homogeneous.html" title="This AdaptableFunctor provides evaluation of a PolynomialTraits_d::Polynomial_d interpreted as a homo...">PolynomialTraits_d::EvaluateHomogeneous</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_is_zero_at_homogeneous.html" title="This AdaptableFunctor returns whether a PolynomialTraits_d::Polynomial_d  is zero at a given homogene...">PolynomialTraits_d::IsZeroAtHomogeneous</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_sign_at_homogeneous.html" title="This AdaptableFunctor returns the sign of a PolynomialTraits_d::Polynomial_d  at a given homogeneous ...">PolynomialTraits_d::SignAtHomogeneous</a></code> </li>
</ul>
<p>Note that substitute allows the substitution of the variables by any type that is <code><a class="elRef" href="../Algebraic_foundations/class_explicit_interoperable.html">ExplicitInteroperable</a></code> with the innermost coefficient type. This is a very powerful tool since it allows the substitution of the variables by polynomials. However, for some standard manipulations such as translation or scaling we require special functors since they are expected to be faster than their equivalent implementation using substitution:</p>
<ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_shift.html" title="This AdaptableBinaryFunction multiplies a PolynomialTraits_d::Polynomial_d by the given power of the ...">PolynomialTraits_d::Shift</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_negate.html" title="This AdaptableUnaryFunction computes  for a given polynomial .">PolynomialTraits_d::Negate</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_invert.html" title="This AdaptableUnaryFunction inverts one variable in a given PolynomialTraits_d::Polynomial_d,...">PolynomialTraits_d::Invert</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_translate.html" title="This AdaptableBinaryFunction translates a PolynomialTraits_d::Polynomial_d with respect to one variab...">PolynomialTraits_d::Translate</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_translate_homogeneous.html" title="Given numerator  and denominator  this AdaptableFunctor translates a PolynomialTraits_d::Polynomial_d...">PolynomialTraits_d::TranslateHomogeneous</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_scale.html" title="Given a constant  this AdaptableBinaryFunction scales a PolynomialTraits_d::Polynomial_d  with respec...">PolynomialTraits_d::Scale</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_scale_homogeneous.html" title="Given a numerator  and a denominator  this AdaptableFunctor scales a PolynomialTraits_d::Polynomial_d...">PolynomialTraits_d::ScaleHomogeneous</a></code> </li>
</ul>
<h2><a class="anchor" id="PolynomialExample_5"></a>
Example</h2>
<p>The following example illustrates the application of some functors discussed above: <br>
<b>File</b> <a class="el" href="_polynomial_2substitute_8cpp-example.html">Polynomial/substitute.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;int,2&gt;::Type</a> Poly_2;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_2&gt;</a>            PT_2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  Poly_2 x = PT_2::Shift()(Poly_2(1),1,0); <span class="comment">// x^1</span></div>
<div class="line">  Poly_2 y = PT_2::Shift()(Poly_2(1),1,1); <span class="comment">// y^1</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  Poly_2 F = 2*x*y + 3*CGAL::ipower(y,3);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial F: "</span> &lt;&lt; F <span class="comment">// = 3*y^3 + (2*x)*y</span></div>
<div class="line">            &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  PT_2::Evaluate <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaa35e3147d1971810230bc1632bf0b3e3">evaluate</a>;</div>
<div class="line">  PT_2::Evaluate_homogeneous hevaluate;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Evaluation considers a polynomials as univariate:</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"F(5): "</span> &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#gaa35e3147d1971810230bc1632bf0b3e3">evaluate</a>(F,5)      <span class="comment">// = 10*x + 375</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// Evaluate_homogeneous considers F as a homogeneous polynomial in</span></div>
<div class="line">  <span class="comment">// the outermost variable only, that is, F is interpreted as</span></div>
<div class="line">  <span class="comment">// F(u,v) = 2*x*u*v^2 + 3 * u^3</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"F(5,7): "</span> &lt;&lt; hevaluate(F,5,7) <span class="comment">// = 490*x + 375</span></div>
<div class="line">            &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  PT_2::Substitute <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga044098c95c086454aae0a3285ad88318">substitute</a>;</div>
<div class="line">  PT_2::Substitute_homogeneous hsubstitute;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Substitute considers a polynomials as multivariate, that is, the</span></div>
<div class="line">  <span class="comment">// new values for the variables are given by an iterator range</span></div>
<div class="line">  <span class="comment">// Note that the value type only has to be interoperable with the innermost</span></div>
<div class="line">  <span class="comment">// coefficient</span></div>
<div class="line">  std::list&lt;Poly_2&gt; replacements;</div>
<div class="line">  replacements.push_back(x-1); <span class="comment">// replace x by x-1</span></div>
<div class="line">  replacements.push_back(y);   <span class="comment">// replace y by y, i.e., do nothing</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The bivariate polynomial F: "</span> &lt;&lt; F <span class="comment">// = 3*y^3 + (2*x)*y</span></div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"F(x-1,y):   "</span> <span class="comment">// = 3*y^3 + (2*x + (-2))*y</span></div>
<div class="line">            &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga044098c95c086454aae0a3285ad88318">substitute</a>(F,replacements.begin(),replacements.end())</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// Substitute_homogeneous considers F as a homogeneous polynomial in</span></div>
<div class="line">  <span class="comment">// all variable, that is, F is interpreted as</span></div>
<div class="line">  <span class="comment">// F(x,y,w) = 2*x*y*w + 3 * y^3</span></div>
<div class="line">  replacements.push_back(y);  <span class="comment">// replace z by y</span></div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"F(x-1,y,y): "</span> <span class="comment">// = 3*y^3 + (2*x + (-2))*y^2</span></div>
<div class="line">            &lt;&lt; hsubstitute(F,replacements.begin(),replacements.end())</div>
<div class="line">            &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga044098c95c086454aae0a3285ad88318"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga044098c95c086454aae0a3285ad88318">CGAL::substitute</a></div><div class="ttdeci">CGAL::Coercion_traits&lt; Polynomial_traits_d&lt; Polynomial_d &gt;::Innermost_coefficient, std::iterator_traits&lt; Input_iterator &gt;::value_type &gt;::Type substitute(const Polynomial_d &amp;p, InputIterator begin, InputIterator end)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_gaa35e3147d1971810230bc1632bf0b3e3"><div class="ttname"><a href="group___pkg_polynomial_functions.html#gaa35e3147d1971810230bc1632bf0b3e3">CGAL::evaluate</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Evaluate::result_type evaluate(const Polynomial_d &amp;p, Polynomial_traits_d&lt; Polynomial_d &gt;::Coefficient_type x)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialResultants"></a>
Resultants, Subresultants and Sturm-Habicht Sequences</h1>
<p>The <code><a class="el" href="class_polynomial_traits__d.html" title="A model of PolynomialTraits_d is associated with a type Polynomial_d. The type Polynomial_d represent...">PolynomialTraits_d</a></code> concept also provides more sophisticated functors for computations with polynomials - computing the resultant of two polynomials, their polynomial subresultant sequence, with or without cofactors, and their principal subresultant coefficients. </p><ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_resultant.html" title="This AdaptableBinaryFunction computes the resultant of two polynomials  and  of type PolynomialTraits...">PolynomialTraits_d::Resultant</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_polynomial_subresultants.html" title="Computes the polynomial subresultant of two polynomials  and  of type PolynomialTraits_d::Polynomial_...">PolynomialTraits_d::PolynomialSubresultants</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_polynomial_subresultants_with_cofactors.html" title="Computes the polynomial subresultant of two polynomials  and  of degree  and , respectively,...">PolynomialTraits_d::PolynomialSubresultantsWithCofactors</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_principal_subresultants.html" title="Computes the principal subresultant of two polynomials  and  of type PolynomialTraits_d::Coefficient_...">PolynomialTraits_d::PrincipalSubresultants</a></code> </li>
</ul>
<p>Moreover, functors to compute the Sturm-Habicht sequence, with or without cofactors, and for the principal Sturm-Habicht coefficients exist. </p><ul>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_sturm_habicht_sequence.html" title="Computes the Sturm-Habicht sequence (aka the signed subresultant sequence) of a polynomial  of type P...">PolynomialTraits_d::SturmHabichtSequence</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_sturm_habicht_sequence_with_cofactors.html" title="Computes the Sturm-Habicht polynomials of a polynomial  of degree , as defined in the documentation o...">PolynomialTraits_d::SturmHabichtSequenceWithCofactors</a></code></li>
<li>
<code><a class="el" href="class_polynomial_traits__d_1_1_principal_sturm_habicht_sequence.html" title="Computes the principal leading coefficients of the Sturm-Habicht sequence of a polynomials  of type P...">PolynomialTraits_d::PrincipalSturmHabichtSequence</a></code> </li>
</ul>
<p>For a formal definition of all used terms, we refer to the corresponding reference pages.</p>
<p>The principal Sturm-Habicht sequence allows to count the number of real roots of a polynomial using the function </p><ul>
<li>
<a class="el" href="group___pkg_polynomial_functions.html#ga0148f1612807b08b433f96c3ce07f2be" title="computes the number of distinct real roots of .">number_of_real_roots()</a>. </li>
</ul>
<p>As input, this function requires an iterator range that represents the principal Sturm-Habicht coefficients. This might look complicated at a first sight, as one has to store the principal Sturm-Habicht sequence temporarily. However, we remark an important property of the (principal) Sturm-Habicht sequence. Having a polynomial \( f_t(x)\) that depends on a parameter \( t\), and its (principal) Sturm-Habicht coefficients \( \mathrm{stha}_0(f_t),\ldots,\mathrm{stha}_n(f_t)\), evaluating \( \mathrm{stha}_0(f_t)\) for \( t=t_0\) yields a valid (principal) Sturm-Habicht sequence for \( f_{t_0}\). The same holds for (principal) subresultants. Thus, it is enough in such situations to compute the sequence once for the parameter \( t\), and call <code><a class="el" href="group___pkg_polynomial_functions.html#ga0148f1612807b08b433f96c3ce07f2be" title="computes the number of distinct real roots of .">number_of_real_roots()</a></code> for each specialized parameter value.</p>
<p>We finally remark that computing subresultants and Sturm-Habicht sequences introduces an enormous coefficient blow-up. An application of the functors therefore does not make sense for built-in integers except for toy examples. To avoid overflows, one should use arbitrary size integer types in real applications.</p>
<h2><a class="anchor" id="PolynomialExample_6"></a>
Example</h2>
<p>The following example illustrates how two compute resultants of two polynomials, and how to count the number of distinct real roots of a polynomial using its principal Sturm-Habicht coefficients.</p>
<p><br>
<b>File</b> <a class="el" href="_polynomial_2subresultants_8cpp-example.html">Polynomial/subresultants.cpp</a> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_traits_d.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Polynomial_type_generator.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;CGAL/Exact_integer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">  <a class="code hl_functionRef" href="../Stream_support/group___pkg_stream_support_ref.html#ga2cbb865dd83eedd780f4a452635b1d28">CGAL::IO::set_pretty_mode</a>(std::cout);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> CGAL::Exact_integer Int;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_classRef" href="../Manual/classunspecified__type.html">CGAL::Polynomial_type_generator&lt;Int,1&gt;::Type</a> Poly_1;</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code hl_class" href="class_c_g_a_l_1_1_polynomial__traits__d.html">CGAL::Polynomial_traits_d&lt;Poly_1&gt;</a>            PT_1;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">//construction using shift</span></div>
<div class="line">  Poly_1 x = PT_1::Shift()(Poly_1(1),1); <span class="comment">// x^1</span></div>
<div class="line"> </div>
<div class="line">  Poly_1 F <span class="comment">// = (x+1)^2*(x-1)*(2x-1)=2x^4+x^3-3x^2-x+1</span></div>
<div class="line">    =   2 * CGAL::ipower(x,4) + 1 * CGAL::ipower(x,3)</div>
<div class="line">      - 3 * CGAL::ipower(x,2) - 1 * CGAL::ipower(x,1)</div>
<div class="line">      + 1 * CGAL::ipower(x,0);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"F="</span> &lt;&lt; F &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  Poly_1 G <span class="comment">// = (x+1)*(x+3)=x^2+4*x+3</span></div>
<div class="line">    =   1 * CGAL::ipower(x,2) + 4 * CGAL::ipower(x,1) + 3 * CGAL::ipower(x,0);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"G="</span> &lt;&lt; G &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Resultant computation:</span></div>
<div class="line">  PT_1::Resultant <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga85e20cee59433ba452ab0a97e3b83e88">resultant</a>;</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The resultant of F and G is: "</span> &lt;&lt; <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga85e20cee59433ba452ab0a97e3b83e88">resultant</a>(F,G) &lt;&lt; std::endl;</div>
<div class="line">  <span class="comment">// It is zero, because F and G have a common factor</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Real root counting:</span></div>
<div class="line">  PT_1::Principal_sturm_habicht_sequence stha;</div>
<div class="line">  std::vector&lt;Int&gt; psc;</div>
<div class="line"> </div>
<div class="line">  stha(F,std::back_inserter(psc));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> roots = <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga0148f1612807b08b433f96c3ce07f2be">CGAL::number_of_real_roots</a>(psc.begin(),psc.end());</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The number of real roots of F is: "</span> &lt;&lt; roots &lt;&lt; std::endl; <span class="comment">// 3</span></div>
<div class="line"> </div>
<div class="line">  roots =  <a class="code hl_function" href="group___pkg_polynomial_functions.html#ga0148f1612807b08b433f96c3ce07f2be">CGAL::number_of_real_roots</a>(G);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">"The number of real roots of G is: "</span> &lt;&lt; roots &lt;&lt; std::endl; <span class="comment">// 2</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga0148f1612807b08b433f96c3ce07f2be"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga0148f1612807b08b433f96c3ce07f2be">CGAL::number_of_real_roots</a></div><div class="ttdeci">int number_of_real_roots(Polynomial_d f)</div><div class="ttdoc">computes the number of distinct real roots of .</div></div>
<div class="ttc" id="agroup___pkg_polynomial_functions_html_ga85e20cee59433ba452ab0a97e3b83e88"><div class="ttname"><a href="group___pkg_polynomial_functions.html#ga85e20cee59433ba452ab0a97e3b83e88">CGAL::resultant</a></div><div class="ttdeci">Polynomial_traits_d&lt; Polynomial_d &gt;::Resultant::result_type resultant(const Polynomial_d &amp;p, const Polynomial_d &amp;q)</div><div class="ttdoc">For a given Polynomial_d, adapts the according functor in Polynomial_traits_d&lt;Polynomial_d&gt;.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="PolynomialDesign"></a>
Design and Implementation History</h1>
<p>This package is the result of the integration process of the NumeriX library of Exacus <a class="el" href="citelist.html#CITEREF_beh-eeeafcs-05">[1]</a> into CGAL.</p>
<p>The class <code><a class="el" href="class_c_g_a_l_1_1_polynomial.html" title="An instance of the data type Polynomial represents a polynomial  from the ring .">Polynomial</a>&lt;Coeff&gt;</code> had been started by Michael Seel within <a class="elRef" href="../STL_Extension/namespace_c_g_a_l_1_1cpp11.html">CGAL</a> as part of the Nef_2 package. As part of the Exacus project it got significantly improved by Arno Eigenwillig and Michael Hemmer.</p>
<p>However, due to the recursive definition the class was rather restricted to the univariate view. Moreover, it is clear that depending on the context other classes that are symmetric in all variables or dedicated for sparse polynomials may be more efficient. As a consequence this package introduced the <code><a class="el" href="class_c_g_a_l_1_1_polynomial__traits__d.html" title="A model of concept PolynomialTraits_d">Polynomial_traits_d</a>&lt;<a class="el" href="class_polynomial__d.html" title="A model of Polynomial_d is representing a multivariate polynomial in  variables over some basic ring ...">Polynomial_d</a>&gt;</code> giving also the symmetric view on polynomials and the opportunity to introduce and use other classes representing polynomials within CGAL. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.6-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"></a> 1.9.6 </li>
  </ul>
</div>
</div>
</body>

</html>
